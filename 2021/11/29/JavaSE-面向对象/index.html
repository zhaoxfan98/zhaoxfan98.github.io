<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>JavaSE-面向对象 | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="Java面向对象将问题分解成一个一个步骤，对每个步骤进行相应的抽象，形成对象，通过不同对象之间的调用，组合解决问题。 就是说，在进行面向对象进行编程的时候，要把属性、行为等封装成对象，然后基于这些对象及对象的能力进行业务逻辑的实现。 比如:想要造一辆车，上来要先把车的各种属性定义出来，然后抽象成一个Car类。 面向对象具有三大基本特征和五大基本原则">
<meta property="og:type" content="article">
<meta property="og:title" content="JavaSE-面向对象">
<meta property="og:url" content="http://example.com/2021/11/29/JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Java面向对象将问题分解成一个一个步骤，对每个步骤进行相应的抽象，形成对象，通过不同对象之间的调用，组合解决问题。 就是说，在进行面向对象进行编程的时候，要把属性、行为等封装成对象，然后基于这些对象及对象的能力进行业务逻辑的实现。 比如:想要造一辆车，上来要先把车的各种属性定义出来，然后抽象成一个Car类。 面向对象具有三大基本特征和五大基本原则">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://example.com/JavaSE/overloading-vs-overriding.png">
<meta property="og:image" content="http://example.com/JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/16145019571199.jpg">
<meta property="og:image" content="http://example.com/JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/15539284762449.jpg">
<meta property="og:image" content="http://example.com/JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/15539289530245.jpg">
<meta property="og:image" content="http://example.com/JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/15539291533175.jpg">
<meta property="og:image" content="http://example.com/JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/15539303829914.jpg">
<meta property="article:published_time" content="2021-11-28T16:00:00.000Z">
<meta property="article:modified_time" content="2021-12-02T08:39:30.006Z">
<meta property="article:author" content="zhaoxfan">
<meta property="article:tag" content="面向对象">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/JavaSE/overloading-vs-overriding.png">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
<meta name="generator" content="Hexo 6.1.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://example.com"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-JavaSE-面向对象" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2021/11/29/JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" class="article-date">
  <time class="dt-published" datetime="2021-11-28T16:00:00.000Z" itemprop="datePublished">2021-11-29</time>
</a>
    
  <div class="article-category">
    <a class="article-category-link" href="/categories/JavaSE/">JavaSE</a>
  </div>

  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      JavaSE-面向对象
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h2 id="Java面向对象"><a href="#Java面向对象" class="headerlink" title="Java面向对象"></a>Java面向对象</h2><p>将问题分解成一个一个步骤，对每个步骤进行相应的抽象，形成对象，通过不同对象之间的调用，组合解决问题。</p>
<p>就是说，在进行面向对象进行编程的时候，要把属性、行为等封装成对象，然后基于这些对象及对象的能力进行业务逻辑的实现。</p>
<p>比如:想要造一辆车，上来要先把车的各种属性定义出来，然后抽象成一个Car类。</p>
<p>面向对象具有三大基本特征和五大基本原则</p>
<span id="more"></span>

<h3 id="三大基本特征"><a href="#三大基本特征" class="headerlink" title="三大基本特征"></a>三大基本特征</h3><h4 id="封装-Encapsulation"><a href="#封装-Encapsulation" class="headerlink" title="封装(Encapsulation)"></a>封装(Encapsulation)</h4><p>所谓封装，也就是把客观事物封装成抽象的类，并且类可以把自己的数据和方法只让可信的类或者对象操作，对不可信的进行信息隐藏。</p>
<p>简单的说，一个类就是一个封装了数据以及操作这些数据的代码的逻辑实体。在一个对象内部，某些代码或某些数据可以是私有的，不能被外界访问。通过这种方式，对象对内部数据提供了不同级别的保护，以防止程序中无关的部分意外的改变或错误的使用了对象的私有部分。</p>
<h4 id="继承-Inheritance"><a href="#继承-Inheritance" class="headerlink" title="继承(Inheritance)"></a>继承(Inheritance)</h4><p>继承是指这样一种能力：它可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。</p>
<p>通过继承创建的新类称为“子类”或“派生类”，被继承的类称为“基类”、“父类”或“超类”。继承的过程，就是从一般到特殊的过程。</p>
<h4 id="多态-Polymorphism"><a href="#多态-Polymorphism" class="headerlink" title="多态(Polymorphism)"></a>多态(Polymorphism)</h4><p>所谓多态就是指一个类实例的相同方法在不同情形有不同表现形式。多态机制使具有不同内部结构的对象可以共享相同的外部接口。</p>
<p>这意味着，虽然针对不同对象的具体操作不同，但通过一个公共的类，它们（那些操作）可以通过相同的方式予以调用。</p>
<p><strong>最常见的多态就是将子类传入父类参数中，运行时调用父类方法时通过传入的子类决定具体的内部结构或行为。</strong></p>
<h3 id="面向对象的五大基本原则"><a href="#面向对象的五大基本原则" class="headerlink" title="面向对象的五大基本原则"></a>面向对象的五大基本原则</h3><h4 id="单一职责原则-Single-Responsibility-Principle"><a href="#单一职责原则-Single-Responsibility-Principle" class="headerlink" title="单一职责原则(Single-Responsibility Principle)"></a>单一职责原则(Single-Responsibility Principle)</h4><p>其核心思想为：一个类，最好只做一件事，只有一个引起它的变化。单一职责原则可以看做是低耦合、高内聚在面向对象原则上的引申，将职责定义为引起变化的原因，以提高内聚性来减少引起变化的原因。</p>
<p>通常意义下的单一职责，就是指只有一种单一功能，不要为类实现过多的功能点，以保证实体只有一个引起它变化的原因。</p>
<h4 id="开放封闭原则-Open-Closed-Principle"><a href="#开放封闭原则-Open-Closed-Principle" class="headerlink" title="开放封闭原则(Open-Closed Principle)"></a>开放封闭原则(Open-Closed Principle)</h4><p>其核心思想是：软件实体应该是可扩展的，而不可修改的。也就是，对扩展开放，对修改封闭的。开放封闭原则主要体现在两个方面1、对扩展开放，意味着有新的需求或变化时，可以对现有代码进行扩展，以适应新的情况。2、对修改封闭，意味着类一旦设计完成，就可以独立完成其工作，而不要对其进行任何尝试的修改。</p>
<p> 实现开放封闭原则的核心思想就是对抽象编程，而不对具体编程，因为抽象相对稳定。让类依赖于固定的抽象，所以修改就是封闭的；而通过面向对象的继承和多态机制，又可以实现对抽象类的继承，通过覆写其方法来改变固有行为，实现新的拓展方法，所以就是开放的。 </p>
<h4 id="Liskov替换原则-Liskov-Substitution-Principle"><a href="#Liskov替换原则-Liskov-Substitution-Principle" class="headerlink" title="Liskov替换原则(Liskov-Substitution Principle)"></a>Liskov替换原则(Liskov-Substitution Principle)</h4><p>核心思想是：子类必须能够替换其基类。这一思想体现为对继承机制的约束规范，只有子类能够替换基类时，才能保证系统在运行期内识别子类，这是保证继承复用的基础。在父类和子类的具体行为中，必须严格把握继承层次中的关系和特征，将基类替换为子类，程序的行为不会发生任何变化。同时，这一约束反过来则是不成立的，子类可以替换基类，但是基类不一定能替换子类。</p>
<p>实现的方法是面向接口编程：将公共部分抽象为基类接口或抽象类，通过Extract Abstract Class，在子类中通过覆写父类的方法实现新的方式支持同样的职责。 <code>Liskov</code>替换原则是关于继承机制的设计原则，违反了<code>Liskov</code>替换原则就必然导致违反开放封闭原则。 <code>Liskov</code>替换原则能够保证系统具有良好的拓展性，同时实现基于多态的抽象机制，能够减少代码冗余，避免运行期的类型判别。</p>
<h4 id="依赖倒置原则-Dependency-Inversion-Principle"><a href="#依赖倒置原则-Dependency-Inversion-Principle" class="headerlink" title="依赖倒置原则(Dependency-Inversion Principle)"></a>依赖倒置原则(Dependency-Inversion Principle)</h4><p>核心思想是：依赖于抽象。具体而言就是高层模块不依赖于底层模块，二者都同依赖于抽象；抽象不依赖于具体，具体依赖于抽象。 我们知道，依赖一定会存在于类与类、模块与模块之间。当两个模块之间存在紧密的耦合关系时，最好的方法就是分离接口和实现：在依赖之间定义一个抽象的接口使得高层模块调用接口，而底层模块实现接口的定义，以此来有效控制耦合关系，达到依赖于抽象的设计目标。</p>
<p>抽象的稳定性决定了系统的稳定性，因为抽象是不变的，依赖于抽象是面向对象设计的精髓，也是依赖倒置原则的核心。 依赖于抽象是一个通用的原则，而某些时候依赖于细节则是在所难免的，必须权衡在抽象和具体之间的取舍，方法不是一层不变的。依赖于抽象，就是对接口编程，不要对实现编程。</p>
<h4 id="接口隔离原则-Interface-Segregation-Principle"><a href="#接口隔离原则-Interface-Segregation-Principle" class="headerlink" title="接口隔离原则(Interface-Segregation Principle)"></a>接口隔离原则(Interface-Segregation Principle)</h4><p>核心思想是：使用多个小的专门的接口，而不要使用一个大的总接口。 具体而言，接口隔离原则体现在：接口应该是内聚的，应该避免“胖”接口。一个类对另外一个类的依赖应该建立在最小的接口上，不要强迫依赖不用的方法，这是一种接口污染。 </p>
<p>分离的手段主要有以下两种：1、委托分离，通过增加一个新的类型来委托客户的请求，隔离客户和接口的直接依赖，但是会增加系统的开销。2、多重继承分离，通过接口多继承来实现客户的需求，这种方式是较好的。</p>
<hr>
<h2 id="封装、继承、多态"><a href="#封装、继承、多态" class="headerlink" title="封装、继承、多态"></a>封装、继承、多态</h2><h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态就是同一操作作用于不同的对象，可以有不同的解释，产生不同的执行结果。按照这个概念来定义的话，多态是一种运行期的状态。</p>
<p>为了实现运行期的多态，或者说动态绑定，需要满足三个条件：</p>
<ul>
<li>有类继承或者接口实现</li>
<li>子类要重写父类的方法</li>
<li>父类的引用指向子类的对象</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Parent</span> &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;</span><br><span class="line">        sout(<span class="string">&quot;im Parent&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Son</span> <span class="keyword">extends</span> <span class="title class_">Parent</span>&#123;<span class="comment">// 1.有类继承或者接口实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;<span class="comment">// 2.子类要重写父类的方法</span></span><br><span class="line">        sout(<span class="string">&quot;im Son&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Daughter</span> <span class="keyword">extends</span> <span class="title class_">Parent</span>&#123;<span class="comment">// 1.有类继承或者接口实现</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">call</span><span class="params">()</span>&#123;<span class="comment">// 2.子类要重写父类的方法</span></span><br><span class="line">        sout(<span class="string">&quot;im Daughter&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Test</span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        <span class="type">Parent</span> <span class="variable">p</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Son</span>(); <span class="comment">//3.父类的引用指向子类的对象</span></span><br><span class="line">        <span class="type">Parent</span> <span class="variable">p1</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Daughter</span>(); <span class="comment">//3.父类的引用指向子类的对象</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这样就实现了多态，同样是<code>Parent</code>类的实例，<code>p</code>和<code>p1</code>分别调用不同类的实现。</p>
<p>在这个示例中，我们已知<code>p</code>是<code>son</code>，<code>p1</code>是<code>daughter</code>。但是，有些时候你所使用的对象并不都是自己声明的。</p>
<p>比如<code>Spring</code>中的<code>IOC</code>出来的对象，在使用的时候就不知道它是谁，但是你可以不用关心它是谁</p>
<blockquote>
<p><code>IOC</code>是<code>Ioc-Inversion of Control</code>的缩写，即控制反转，是一种设计思想，意味着将你设计好的对象交给容器控制，而不是传统的在你的对象内部直接控制。</p>
<p>即，当我们使用<code>Spring</code>框架时，对象是<code>Spring</code>容器创建出来并由容器进行管理，我们只需要使用就行了。</p>
</blockquote>
<h3 id="方法重写与重载"><a href="#方法重写与重载" class="headerlink" title="方法重写与重载"></a>方法重写与重载</h3><p><img src="/./JavaSE/overloading-vs-overriding.png" alt="overloading-vs-overriding"></p>
<p><strong>重写</strong>:指的是在Java的子类与父类中有两个名称、参数列表都相同的方法的情况。由于他们具有相同的方法签名，所以子类中的新方法将覆盖父类中原有的方法。</p>
<p><strong>重载</strong>：函数或者方法有同样的名称，但是参数列表不相同的情形，这样的同名不同参数的函数或者方法之间，互相称之为重载函数或者方法。</p>
<p><em><strong>重载<code>VS</code>重写</strong></em></p>
<blockquote>
<ol>
<li>重载是一个编译期概念、重写是一个运行期概念</li>
<li>重载遵循所谓“编译期绑定”，即在编译时根据参数变量的类型判断应该调用哪个方法</li>
<li>重写遵循所谓“运行期绑定”，即在运行的时候，根据引用变量所指向的实际对象的类型来调用方法</li>
<li>因为在编译期已经确定调用哪个方法，所以重载并不是多态。而重写是多态。重载只是一种语言特性，是一种语法规则，与多态无关，与面向对象也无关</li>
</ol>
</blockquote>
<h4 id="重写的例子"><a href="#重写的例子" class="headerlink" title="重写的例子"></a>重写的例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;woof &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Hound</span> <span class="keyword">extends</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sniff</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;sniff &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;bowl&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">OverridingTest</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String [] args)</span>&#123;</span><br><span class="line">        <span class="type">Dog</span> <span class="variable">dog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Hound</span>();</span><br><span class="line">        dog.bark();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果:bowl</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的例子中，<code>dog</code>对象被定义为<code>Dog</code>类型。在编译期，编译器会检查Dog类中是否有可访问的<code>bark()</code>方法，只要其中包含<code>bark（）</code>方法，那么就可以编译通过。在运行期，<code>Hound</code>对象被<code>new</code>出来，并赋值给<code>dog</code>变量，这时，JVM是明确的知道<code>dog</code>变量指向的其实是<code>Hound</code>对象的引用。所以，当<code>dog</code>调用<code>bark()</code>方法的时候，就会调用<code>Hound</code>类中定义的<code>bark（）</code>方法。这就是所谓的动态多态性。</p>
<h4 id="重写的条件"><a href="#重写的条件" class="headerlink" title="重写的条件"></a>重写的条件</h4><ol>
<li>参数列表、返回类型必须完全与被重写方法的相同</li>
<li>访问级别的限制性一定不能比被重写方法的强</li>
<li>重写方法一定不能抛出新的检查异常或比被重写的方法声明的检查异常更广泛的检查异常</li>
<li>不能重写被标示为final的方法</li>
<li>如果不能继承一个方法，则不能重写这个方法</li>
</ol>
<h4 id="重载的例子"><a href="#重载的例子" class="headerlink" title="重载的例子"></a>重载的例子</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Dog</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;woof &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//overloading method</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">bark</span><span class="params">(<span class="type">int</span> num)</span>&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;num; i++)</span><br><span class="line">            System.out.println(<span class="string">&quot;woof &quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>上面的代码中，定义了两个bark方法，一个是没有参数的bark方法，另外一个是包含一个<code>int</code>类型参数的bark方法。在编译期，编译期可以根据方法签名（方法名和参数情况）情况确定哪个方法被调用。</p>
<h4 id="重载的条件"><a href="#重载的条件" class="headerlink" title="重载的条件"></a>重载的条件</h4><ol>
<li>被重载的方法必须改变参数列表</li>
<li>被重载的方法可以改变返回类型、访问修饰符、访问修饰符</li>
<li>方法能够在同一个类中或者在一个子类中被重载</li>
</ol>
<h3 id="Java的继承与实现"><a href="#Java的继承与实现" class="headerlink" title="Java的继承与实现"></a>Java的继承与实现</h3><p>继承可以使用现有类的所有功能，并在无需重新编写原来的类的情况下对这些功能进行扩展。这种派生方式体现了<em>传递性</em>，在Java中，除了继承，还有一种提现传递性的方式叫做实现。</p>
<p>继承和实现两者的明确定义和区别如下：</p>
<blockquote>
<p>继承：如果多个类的某个部分的功能相同，那么可以抽象出一个类出来，把他们的相同部分都放到父类里，让他们都继承这个类。</p>
<p>实现：如果多个类处理的目标是一样的，但是处理的方法方式不同，那么就定义一个接口，也就是一个标准，让他们的实现这个接口，各自实现自己具体的处理方法来处理那个目标</p>
</blockquote>
<p>继承指的是一个类（称为子类、子接口）继承另外的一个类（称为父类、父接口）的功能，并可以增加它自己的新功能的能力。所以，继承的根本原因是因为要<em>复用</em>，而实现的根本原因是需要定义一个<em>标准</em>。</p>
<p>在Java中，继承使用<code>extends</code>关键字实现，而实现通过<code>implements</code>关键字</p>
<h3 id="Java为什么不支持多继承"><a href="#Java为什么不支持多继承" class="headerlink" title="Java为什么不支持多继承"></a>Java为什么不支持多继承</h3><p>一个类，只有一个父类的情况，我们叫做单继承。而一个类，同时有多个父类的情况，叫做多继承。</p>
<p>在Java中，一个类，只能通过extends关键字继承一个类，不允许多继承。但是，多继承在其他的面向对象语言中是有可能支持的。</p>
<p>像C++就是支持多继承的，主要是因为编程的过程是对现实世界的一种抽象，而现实世界中，确实存在着需要多继承的情况。</p>
<p>例如，可以创造一个“哺乳类动物”类别，拥有进食、繁殖等的功能；然后定义一个子类型“猫”，它可以从父类继承上述功能。</p>
<p>但是，”猫”还可以作为”宠物”的子类，拥有一些宠物独有的能力。</p>
<p>所以，有些面向对象语言是支持多重继承的。</p>
<p>但是，多年以来，多重继承一直都是一个敏感的话题，反对者指它增加了程序的复杂性与含糊性。</p>
<h4 id="菱形继承问题"><a href="#菱形继承问题" class="headerlink" title="菱形继承问题"></a>菱形继承问题</h4><p>假设我们有类B和类C，它们都继承了相同的类A。另外我们还有类D，类D通过多重继承机制继承了类B和类C。</p>
<p><img src="/./JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/16145019571199.jpg" alt="img"></p>
<p>这时候，因为D同时继承了B和C，并且B和C又同时继承了A，那么，D中就会因为多重继承，继承到两份来自A中的属性和方法。</p>
<p>这时候，在使用D的时候，如果想要调用一个定义在A中的方法时，就会出现歧义。</p>
<p>因为这样的继承关系的形状类似于菱形，因此这个问题被形象地称为菱形继承问题。</p>
<p>而C++为了解决菱形继承问题，又引入了<strong>虚继承</strong>。</p>
<p>因为支持多继承，引入了菱形继承问题，又因为要解决菱形继承问题，引入了虚继承。而经过分析，人们发现我们其实真正想要使用多继承的情况并不多。</p>
<p>所以，在 Java 中，不允许“实现多继承”，即一个类不允许继承多个父类。但是 Java 允许“声明多继承”，即一个类可以实现多个接口，一个接口也可以继承多个父接口。由于接口只允许有方法声明而不允许有方法实现（Java 8以前），这就避免了 C++ 中多继承的歧义问题。</p>
<h3 id="Java的继承与组合"><a href="#Java的继承与组合" class="headerlink" title="Java的继承与组合"></a>Java的继承与组合</h3><p>遇到想要复用的场景就直接使用继承，这样做是不对的。长期大量的使用继承会给代码带来很高的维护成本。</p>
<h4 id="面向对象的复用技术"><a href="#面向对象的复用技术" class="headerlink" title="面向对象的复用技术"></a>面向对象的复用技术</h4><p>Java代码的复用有继承，组合以及代理三种具体的表现形式。下面介绍继承复用和组合复用</p>
<p>继承是类与类或者接口与接口之间最常见的一种关系；继承是一种<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Is-a"><code>is-a</code></a>关系</p>
<blockquote>
<p>继承是类与类或者接口与接口之间最常见的一种关系；继承是一种<a target="_blank" rel="noopener" href="https://zh.wikipedia.org/wiki/Is-a"><code>is-a</code></a>关系</p>
</blockquote>
<p>组合(Composition)体现的是整体与部分、拥有的关系，即<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/Has-a"><code>has-a</code></a>的关系</p>
<blockquote>
<p>has-a：表示”有一个”的关系，如狗有一个尾巴</p>
</blockquote>
<h4 id="组合与继承的区别和联系"><a href="#组合与继承的区别和联系" class="headerlink" title="组合与继承的区别和联系"></a>组合与继承的区别和联系</h4><blockquote>
<p>在<code>继承</code>结构中，父类的内部细节对于子类是可见的。所以我们通常也可以说通过继承的代码复用是一种<code>白盒式代码复用</code>。（如果基类的实现发生改变，那么派生类的实现也将随之改变。这样就导致了子类行为的不可预知性；）</p>
<p><code>组合</code>是通过对现有的对象进行拼装（组合）产生新的、更复杂的功能。因为在对象之间，各自的内部细节是不可见的，所以我们也说这种方式的代码复用是<code>黑盒式代码复用</code>。（因为组合中一般都定义一个类型，所以在编译期根本不知道具体会调用哪个实现类的方法）</p>
<p><code>继承</code>，在写代码的时候就要指名具体继承哪个类，所以，在<code>编译期</code>就确定了关系。（从基类继承来的实现是无法在运行期动态改变的，因此降低了应用的灵活性。）</p>
<p><code>组合</code>，在写代码的时候可以采用面向接口编程。所以，类的组合关系一般在<code>运行期</code>确定。</p>
</blockquote>
<h3 id="构造函数与默认构造函数"><a href="#构造函数与默认构造函数" class="headerlink" title="构造函数与默认构造函数"></a>构造函数与默认构造函数</h3><p>构造函数，是一种特殊的方法。 主要用来在创建对象时初始化对象， 即为对象成员变量赋初始值，总与new运算符一起使用在创建对象的语句中。</p>
<p>特别的一个类可以有多个构造函数，可根据其参数个数的不同或参数类型的不同来区分它们即构造函数的重载。</p>
<p>构造函数跟一般的实例方法十分相似；但是与其它方法不同，构造器没有返回类型，不会被继承，且可以有范围修饰符。</p>
<p>构造器的函数名称必须和它所属的类的名称相同。它承担着初始化对象数据成员的任务。</p>
<p>如果在编写一个可实例化的类时没有专门编写构造函数，多数编程语言会自动生成缺省构造器（默认构造函数）。默认构造函数一般会把成员变量的值初始化为默认值，如<code>int</code> -&gt; 0，<code>Integer</code> -&gt; <code>null</code>。</p>
<p>但是，如果我们手动在某个类中定义了一个有参数的构造函数，那么这个默认的无参构造函数就不会自动添加了。需要手动创建。</p>
<h3 id="类变量、成员变量和局部变量"><a href="#类变量、成员变量和局部变量" class="headerlink" title="类变量、成员变量和局部变量"></a>类变量、成员变量和局部变量</h3><p>Java中共有三种变量，分别是类变量、成员变量和局部变量。他们分别存放在JVM的方法区、堆内存和栈内存中。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Variables</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 类变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">int</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 成员变量</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> b;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 局部变量</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> c</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">test</span><span class="params">(<span class="type">int</span> c)</span>&#123;</span><br><span class="line">        <span class="type">int</span> d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="成员变量和方法作用域"><a href="#成员变量和方法作用域" class="headerlink" title="成员变量和方法作用域"></a>成员变量和方法作用域</h3><p>对于成员变量和方法的作用域，public，protected，private以及不写之间的区别：</p>
<p><strong><code>public</code></strong>:表明该成员变量或者方法是对所有类或者对象都是可见的,所有类或者对象都可以直接访问</p>
<p><strong><code>private</code></strong>:表明该成员变量或者方法是私有的,只有当前类对其具有访问权限,除此之外其他类或者对象都没有访问权限.子类也没有访问权限.</p>
<p><strong><code>protected</code></strong>:表明成员变量或者方法对类自身,与同在一个包中的其他类可见,其他包下的类不可访问,除非是他的子类</p>
<p><strong><code>default</code></strong>:表明该成员变量或者方法只有自己和其位于同一个包的内可见,其他包内的类不能访问,即便是它的子类</p>
<hr>
<h2 id="平台无关性"><a href="#平台无关性" class="headerlink" title="平台无关性"></a>平台无关性</h2><p>平台无关性就是一种语言在计算机上的运行不受平台的约束，一次编译，到处执行（Write Once ,Run Anywhere）。</p>
<p>也就是说，用Java创建的可执行二进制程序，能够不加改变的运行于多个平台。</p>
<h3 id="平台无关性的实现"><a href="#平台无关性的实现" class="headerlink" title="平台无关性的实现"></a>平台无关性的实现</h3><p>对于Java的平台无关性的支持，就像对安全性和网络移动性的支持一样，是分布在整个Java体系结构中的。其中扮演者重要的角色的有Java语言规范、Class文件、Java虚拟机（JVM）等。</p>
<h3 id="编译原理基础"><a href="#编译原理基础" class="headerlink" title="编译原理基础"></a>编译原理基础</h3><p>在Java平台中，想要把Java文件，编译成二进制文件，需要经过两步编译，前端编译和后端编译：</p>
<p><img src="/./JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/15539284762449.jpg" alt="img"></p>
<p>前端编译主要指与源语言有关但与目标机无关的部分。Java中，我们所熟知的<code>javac</code>的编译就是前端编译。除了这种以外，我们使用的很多IDE，如eclipse，idea等，都内置了前端编译器。主要功能就是把<code>.java</code>代码转换成<code>.class</code>代码。</p>
<p>后端编译主要是将中间代码再翻译成机器语言。Java中，这一步骤就是Java虚拟机来执行的。</p>
<p><img src="/./JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/15539289530245.jpg" alt="img"></p>
<p>所以，我们说的，Java的平台无关性实现主要作用于以上阶段。如下图所示：</p>
<p><img src="/./JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/15539291533175.jpg" alt="img"></p>
<h4 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h4><p>所谓平台无关性，就是说要能够做到可以在多个平台上都能无缝对接。但是，对于不同的平台，硬件和操作系统肯定都是不一样的。</p>
<p>对于不同的硬件和操作系统，最主要的区别就是指令不同。比如同样执行a+b，A操作系统对应的二进制指令可能是10001000，而B操作系统对应的指令可能是11101110。那么，想要做到跨平台，最重要的就是可以根据对应的硬件和操作系统生成对应的二进制指令。</p>
<p>而这一工作，主要由我们的Java虚拟机完成。虽然Java语言是平台无关的，但是JVM却是平台有关的，不同的操作系统上面要安装对应的JVM。</p>
<p>有了Java虚拟机，想要执行a+b操作，A操作系统上面的虚拟机就会把指令翻译成10001000，B操作系统上面的虚拟机就会把指令翻译成11101110。</p>
<p><img src="/./JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/15539303829914.jpg" alt="img"></p>
<p>所以，Java之所以可以做到跨平台，是因为Java虚拟机充当了桥梁。他扮演了运行时Java程序与其下的硬件和操作系统之间的缓冲角色。</p>
<h4 id="字节码"><a href="#字节码" class="headerlink" title="字节码"></a>字节码</h4><p>各种不同的平台的虚拟机都使用统一的程序存储格式——字节码（<code>ByteCode</code>）是构成平台无关性的另一个基石。Java虚拟机只与由字节码组成的Class文件进行交互。</p>
<p>我们说Java语言可以Write Once ,Run Anywhere。这里的Write其实指的就是生成Class文件的过程。</p>
<p>因为Java Class文件可以在任何平台创建，也可以被任何平台的Java虚拟机装载并执行，所以才有了Java的平台无关性。</p>
<h4 id="Java语言规范"><a href="#Java语言规范" class="headerlink" title="Java语言规范"></a>Java语言规范</h4><p>已经有了统一的Class文件，以及可以在不同平台上将Class文件翻译成对应的二进制文件的Java虚拟机，Java就可以彻底实现跨平台了吗？</p>
<p>其实并不是的，Java语言在跨平台方面也是做了一些努力的，这些努力被定义在Java语言规范中。</p>
<p>比如，Java中基本数据类型的值域和行为都是由其自己定义的。而C&#x2F;C++中，基本数据类型是由它的占位宽度决定的，占位宽度则是由所在平台决定的。所以，在不同的平台中，对于同一个C++程序的编译结果会出现不同的行为。</p>
<p>举一个简单的例子，对于<code>int</code>类型，在Java中，<code>int</code>占4个字节，这是固定的。</p>
<p>但是在C++中却不是固定的了。在16位计算机上，<code>int</code>类型的长度可能为两字节；在32位计算机上，可能为4字节；当64位计算机流行起来后，<code>int</code>类型的长度可能会达到8字节。（这里说的都是可能）</p>
<p>通过保证基本数据类型在所有平台的一致性，Java语言为平台无关性提供强了有力的支持。</p>
<h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul>
<li>Java语言规范：通过规定<code>Java</code>语言中基本数据类型的取值范围和行为</li>
<li>Class文件：所有Java文件都要编译成统一的Class文件</li>
<li>Java虚拟机：将Class文件转成对应平台的二进制文件等</li>
</ul>
<p>Java的平台无关性是建立在Java虚拟机的平台有关性基础之上的，是因为Java虚拟机屏蔽了底层操作系统和硬件的差异</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><p><a target="_blank" rel="noopener" href="http://hollischuang.gitee.io/tobetopjavaer/#/">Java工程师成神之路 (gitee.io)</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://example.com/2021/11/29/JavaSE-%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" data-id="cl0yocch4001ldoq1cpze6ab1" data-title="JavaSE-面向对象" class="article-share-link">Share</a>
      
      
      
  <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="tag">面向对象</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2021/11/30/%E7%BD%AE%E8%BA%AB%E4%BA%8B%E5%86%85-%E5%85%B0%E5%B0%8F%E6%AC%A2/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          《置身事内-兰小欢》
        
      </div>
    </a>
  
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Categories</h3>
    <div class="widget">
      <ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/JavaEE/">JavaEE</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/JavaSE/">JavaSE</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/MySQL/">MySQL</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AD%E5%9B%BD%E6%94%BF%E6%B2%BB/">中国政治</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E4%B8%AD%E5%9B%BD%E7%BB%8F%E6%B5%8E/">中国经济</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%8E%86%E5%8F%B2/">历史</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E5%BF%83%E7%90%86%E5%AD%A6/">心理学</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/%E6%94%BF%E6%B2%BB/">政治</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/JavaSE/" rel="tag">JavaSE</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Maven/" rel="tag">Maven</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MyBatis/" rel="tag">MyBatis</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/MySQL/" rel="tag">MySQL</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Spring/" rel="tag">Spring</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%96%E7%95%8C%E6%94%BF%E6%B2%BB/" rel="tag">世界政治</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B8%AD%E5%9B%BD%E6%94%BF%E6%B2%BB/" rel="tag">中国政治</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" rel="tag">基础知识</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BF%83%E7%90%86%E5%AD%A6/" rel="tag">心理学</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%98%8E%E6%9C%9D/" rel="tag">明朝</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%B8%85%E5%8F%B2/" rel="tag">清史</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%BB%8F%E6%B5%8E/" rel="tag">经济</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" rel="tag">面向对象</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/JavaSE/" style="font-size: 20px;">JavaSE</a> <a href="/tags/Maven/" style="font-size: 10px;">Maven</a> <a href="/tags/MyBatis/" style="font-size: 10px;">MyBatis</a> <a href="/tags/MySQL/" style="font-size: 10px;">MySQL</a> <a href="/tags/Spring/" style="font-size: 10px;">Spring</a> <a href="/tags/%E4%B8%96%E7%95%8C%E6%94%BF%E6%B2%BB/" style="font-size: 10px;">世界政治</a> <a href="/tags/%E4%B8%AD%E5%9B%BD%E6%94%BF%E6%B2%BB/" style="font-size: 10px;">中国政治</a> <a href="/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" style="font-size: 10px;">基础知识</a> <a href="/tags/%E5%BF%83%E7%90%86%E5%AD%A6/" style="font-size: 10px;">心理学</a> <a href="/tags/%E6%98%8E%E6%9C%9D/" style="font-size: 10px;">明朝</a> <a href="/tags/%E6%B8%85%E5%8F%B2/" style="font-size: 10px;">清史</a> <a href="/tags/%E7%BB%8F%E6%B5%8E/" style="font-size: 10px;">经济</a> <a href="/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/" style="font-size: 10px;">面向对象</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">March 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/01/">January 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/12/">December 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">November 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2022/03/20/%E4%B8%AD%E5%9B%BD%E5%8E%86%E4%BB%A3%E6%94%BF%E6%B2%BB%E5%BE%97%E5%A4%B1-%E9%92%B1%E7%A9%86/">《中国历代政治得失-钱穆》</a>
          </li>
        
          <li>
            <a href="/2022/01/04/MyBatis-Plus/">MyBatis-Plus</a>
          </li>
        
          <li>
            <a href="/2022/01/01/%E9%9C%80%E8%A6%81%E5%BB%B6%E8%BF%9F%E6%BB%A1%E8%B6%B3%E6%84%9F%E5%90%97/">需要延迟满足感吗?</a>
          </li>
        
          <li>
            <a href="/2022/01/01/Spring-note/">SSM笔记</a>
          </li>
        
          <li>
            <a href="/2021/12/26/Maven-note/">Maven-note</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2022 zhaoxfan<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.4.1.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>