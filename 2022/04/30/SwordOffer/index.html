<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="算法," />










<meta name="description" content="9.用两个栈实现队列  思路：维护两个栈，第一个栈支持插入操作，第二个栈支持删除操作。 在执行删除操作的时候我们首先看下第二个栈是否为空。如果为空，我们将第一个栈里的元素一个个弹出插入到第二个栈里，这样第二个栈里元素的顺序就是待删除的元素的顺序，要执行删除操作的时候我们直接弹出第二个栈的元素返回即可">
<meta property="og:type" content="article">
<meta property="og:title" content="剑指Offer">
<meta property="og:url" content="http://example.com/2022/04/30/SwordOffer/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="9.用两个栈实现队列  思路：维护两个栈，第一个栈支持插入操作，第二个栈支持删除操作。 在执行删除操作的时候我们首先看下第二个栈是否为空。如果为空，我们将第一个栈里的元素一个个弹出插入到第二个栈里，这样第二个栈里元素的顺序就是待删除的元素的顺序，要执行删除操作的时候我们直接弹出第二个栈的元素返回即可">
<meta property="og:locale">
<meta property="og:image" content="http://example.com/SwordOffer/9.png">
<meta property="og:image" content="http://example.com/SwordOffer/30.png">
<meta property="og:image" content="http://example.com/SwordOffer/6.png">
<meta property="og:image" content="http://example.com/SwordOffer/24.png">
<meta property="og:image" content="http://example.com/SwordOffer/35.png">
<meta property="og:image" content="http://example.com/SwordOffer/5.png">
<meta property="og:image" content="http://example.com/SwordOffer/58.png">
<meta property="og:image" content="http://example.com/SwordOffer/3.png">
<meta property="og:image" content="http://example.com/SwordOffer/53.png">
<meta property="og:image" content="http://example.com/SwordOffer/53_2.png">
<meta property="og:image" content="http://example.com/SwordOffer/4.png">
<meta property="og:image" content="http://example.com/SwordOffer/11.png">
<meta property="og:image" content="http://example.com/SwordOffer/11_2.png">
<meta property="og:image" content="http://example.com/SwordOffer/50.png">
<meta property="og:image" content="http://example.com/SwordOffer/32-1.png">
<meta property="og:image" content="http://example.com/SwordOffer/32-2.png">
<meta property="og:image" content="http://example.com/SwordOffer/32-3.png">
<meta property="og:image" content="http://example.com/SwordOffer/10-1.png">
<meta property="og:image" content="http://example.com/SwordOffer/10-2.png">
<meta property="og:image" content="http://example.com/SwordOffer/63.png">
<meta property="og:image" content="http://example.com/SwordOffer/42.png">
<meta property="og:image" content="http://example.com/SwordOffer/47.png">
<meta property="og:image" content="http://example.com/SwordOffer/46.png">
<meta property="og:image" content="http://example.com/SwordOffer/46_1.png">
<meta property="og:image" content="http://example.com/SwordOffer/48.png">
<meta property="og:image" content="http://example.com/SwordOffer/48_1.png">
<meta property="og:image" content="http://example.com/SwordOffer/18.png">
<meta property="og:image" content="http://example.com/SwordOffer/22.png">
<meta property="og:image" content="http://example.com/SwordOffer/25.png">
<meta property="og:image" content="http://example.com/SwordOffer/52.png">
<meta property="og:image" content="http://example.com/SwordOffer/21.png">
<meta property="og:image" content="http://example.com/SwordOffer/57..png">
<meta property="og:image" content="http://example.com/SwordOffer/58_1.png">
<meta property="og:image" content="http://example.com/SwordOffer/12.png">
<meta property="og:image" content="http://example.com/SwordOffer/13.png">
<meta property="og:image" content="http://example.com/SwordOffer/34.png">
<meta property="og:image" content="http://example.com/SwordOffer/36.png">
<meta property="og:image" content="http://example.com/SwordOffer/54.png">
<meta property="og:image" content="http://example.com/SwordOffer/45.png">
<meta property="og:image" content="http://example.com/SwordOffer/61.png">
<meta property="og:image" content="http://example.com/SwordOffer/40.png">
<meta property="og:image" content="http://example.com/SwordOffer/41.png">
<meta property="og:image" content="http://example.com/SwordOffer/55_1.png">
<meta property="og:image" content="http://example.com/SwordOffer/55_2.png">
<meta property="og:image" content="http://example.com/SwordOffer/64.png">
<meta property="og:image" content="http://example.com/SwordOffer/68_1.png">
<meta property="og:image" content="http://example.com/SwordOffer/68_2.png">
<meta property="og:image" content="http://example.com/SwordOffer/7.png">
<meta property="og:image" content="http://example.com/SwordOffer/16.png">
<meta property="og:image" content="http://example.com/SwordOffer/33.png">
<meta property="og:image" content="http://example.com/SwordOffer/15.png">
<meta property="og:image" content="http://example.com/SwordOffer/65.png">
<meta property="og:image" content="http://example.com/SwordOffer/56_1.png">
<meta property="og:image" content="http://example.com/SwordOffer/56_2.png">
<meta property="og:image" content="http://example.com/SwordOffer/39.png">
<meta property="og:image" content="http://example.com/SwordOffer/66.png">
<meta property="og:image" content="http://example.com/SwordOffer/14_1.png">
<meta property="og:image" content="http://example.com/SwordOffer/57_2.png">
<meta property="og:image" content="http://example.com/SwordOffer/62.png">
<meta property="og:image" content="http://example.com/SwordOffer/29.png">
<meta property="og:image" content="http://example.com/SwordOffer/31.png">
<meta property="og:image" content="http://example.com/SwordOffer/20.png">
<meta property="og:image" content="http://example.com/SwordOffer/67.png">
<meta property="og:image" content="http://example.com/SwordOffer/59_1.png">
<meta property="og:image" content="http://example.com/SwordOffer/59_2.png">
<meta property="og:image" content="http://example.com/SwordOffer/37.png">
<meta property="og:image" content="http://example.com/SwordOffer/38.png">
<meta property="og:image" content="http://example.com/SwordOffer/19.png">
<meta property="og:image" content="http://example.com/SwordOffer/49.png">
<meta property="og:image" content="http://example.com/SwordOffer/60.png">
<meta property="og:image" content="http://example.com/SwordOffer/51.png">
<meta property="og:image" content="http://example.com/SwordOffer/14_2.png">
<meta property="article:published_time" content="2022-04-30T07:49:33.902Z">
<meta property="article:modified_time" content="2022-05-10T06:33:39.732Z">
<meta property="article:author" content="zhaoxfan">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/SwordOffer/9.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://example.com/2022/04/30/SwordOffer/"/>





  <title>剑指Offer | Hexo</title>
  








<meta name="generator" content="Hexo 6.1.0"></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Hexo</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-question-circle"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/04/30/SwordOffer/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/cat.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">剑指Offer</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2022-04-30T15:49:33+08:00">
                2022-04-30
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%9F%BA%E7%A1%80/" itemprop="url" rel="index">
                    <span itemprop="name">基础</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          
            <div class="post-wordcount">
              
                
                <span class="post-meta-item-icon">
                  <i class="fa fa-file-word-o"></i>
                </span>
                
                  <span class="post-meta-item-text">字数统计&#58;</span>
                
                <span title="字数统计">
                  
                </span>
              

              
                <span class="post-meta-divider">|</span>
              

              
                <span class="post-meta-item-icon">
                  <i class="fa fa-clock-o"></i>
                </span>
                
                  <span class="post-meta-item-text">阅读时长 &asymp;</span>
                
                <span title="阅读时长">
                  
                </span>
              
            </div>
          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h2 id="9-用两个栈实现队列"><a href="#9-用两个栈实现队列" class="headerlink" title="9.用两个栈实现队列"></a>9.用两个栈实现队列</h2><p><img src="/./SwordOffer/9.png" alt="image-20220316110237876"></p>
<blockquote>
<p>思路：维护两个栈，第一个栈支持插入操作，第二个栈支持删除操作。</p>
<p>在执行删除操作的时候我们首先看下第二个栈是否为空。如果为空，我们将第一个栈里的元素一个个弹出插入到第二个栈里，这样第二个栈里元素的顺序就是待删除的元素的顺序，要执行删除操作的时候我们直接弹出第二个栈的元素返回即可</p>
</blockquote>
<span id="more"></span>

<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">CQueue</span> &#123;</span><br><span class="line">    Deque&lt;Integer&gt; stack1;</span><br><span class="line">    Deque&lt;Integer&gt; stack2;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">CQueue</span><span class="params">()</span> &#123;</span><br><span class="line">    	stack1 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">    	stack2 = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">appendTail</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">		stack1.push(value);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">deleteHead</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="comment">//如果第二个栈为空</span></span><br><span class="line">		<span class="keyword">if</span> (stack2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">while</span>(!stack1.isEmpty()) &#123;</span><br><span class="line">                stack2.push(stack1.pop());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (stack2.isEmpty()) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">deleteItem</span> <span class="operator">=</span> stack2.pop();</span><br><span class="line">            <span class="keyword">return</span> deleteItem;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="30-包含min函数的栈"><a href="#30-包含min函数的栈" class="headerlink" title="30.包含min函数的栈"></a>30.包含min函数的栈</h2><p><img src="/./SwordOffer/30.png" alt="image-20220316111044141"></p>
<blockquote>
<p>思路：</p>
<ul>
<li>建立一个ListNode结构类</li>
<li>MinStack类维护一个ListNode头节点，初始为null</li>
<li>push方法：头节点为null直接新建；头节点不为null时，在头结点之前插入一个节点，值为x，next指向头节点；将新的节点重新赋值给头节点，也就是每次push都将值插入头节点之前</li>
<li>pop方法：直接将头节点指向头节点的下一个节点，也就是每次pop头节点，从而实现后进后出的栈操作</li>
<li>top方法：直接返回头节点的值即可</li>
<li>min方法：直接返回头节点的min值即可</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">	</span><br><span class="line">    <span class="comment">//链表实现：每个节点加一个额外属性，作为当前最小值</span></span><br><span class="line">    <span class="keyword">private</span> Node head;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">		</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (head == <span class="literal">null</span>)</span><br><span class="line">            head = <span class="keyword">new</span> <span class="title class_">Node</span>(x, x, <span class="literal">null</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            head = <span class="keyword">new</span> <span class="title class_">Node</span>(x, Math.min(head.min, x), head);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">		head = head.next;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> head.val;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> head.min;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">        <span class="type">int</span> val;</span><br><span class="line">        <span class="type">int</span> min;</span><br><span class="line">        Node next;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">public</span> <span class="title function_">Node</span> <span class="params">(<span class="type">int</span> val, <span class="type">int</span> min, Node next)</span> &#123;</span><br><span class="line">            <span class="built_in">this</span>.val = val;</span><br><span class="line">            <span class="built_in">this</span>.min = min;</span><br><span class="line">            <span class="built_in">this</span>.next = next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路：获取栈的最小值需要遍历整个栈，复杂度为O(N)，要将复杂度降为O(1)，可通过建立辅助栈实现</p>
<p>数据栈A用于存储所有元素，保证入栈函数、出栈函数、获取栈顶函数的正常逻辑</p>
<p>辅助栈B存储栈A中所有非严格降序的元素，则栈A中的最小元素始终对应栈B的栈顶元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MinStack</span> &#123;</span><br><span class="line">    <span class="comment">//两个队列实现</span></span><br><span class="line">    Deque&lt;Integer&gt; xStack;</span><br><span class="line">    Deque&lt;Integer&gt; minStack;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MinStack</span><span class="params">()</span> &#123;</span><br><span class="line">        xStack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        minStack = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;Integer&gt;();</span><br><span class="line">        minStack.push(Integer.MAX_VALUE);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        xStack.push(x);</span><br><span class="line">        minStack.push(Math.min(x, minStack.peek()));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">pop</span><span class="params">()</span> &#123;</span><br><span class="line">        xStack.pop();</span><br><span class="line">        minStack.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">top</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> xStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">min</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> minStack.peek();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="6-从尾到头打印链表"><a href="#6-从尾到头打印链表" class="headerlink" title="6.从尾到头打印链表"></a>6.从尾到头打印链表</h2><p><img src="/./SwordOffer/6.png" alt="image-20220317132710595"></p>
<blockquote>
<p>思路：数组倒序存储（反转链表、栈均可）</p>
<ul>
<li>遍历获取链表长度</li>
<li>从后向前按照索引填数组</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * public class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] reversePrint(ListNode head) &#123;</span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">node</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">null</span>) &#123;</span><br><span class="line">            len++;</span><br><span class="line">            node=node.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="literal">null</span>) &#123;</span><br><span class="line">            res[--len] = head.val;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="24-反转链表"><a href="#24-反转链表" class="headerlink" title="24.反转链表"></a>24.反转链表</h2><p><img src="/SwordOffer/24.png" alt="image-20220317133142612"></p>
<blockquote>
<p>思路：迭代</p>
<p>在遍历链表时，将当前节点的next指针改为指向前一个节点。由于节点没有引用其前一个节点，因此必须事先存储其前一个节点。在更改引用之前，还需要存储后一个节点。最后返回新的头引用。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">	<span class="keyword">public</span> ListNode <span class="title function_">reverseList</span><span class="params">(ListNode head)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">cur</span> <span class="operator">=</span> head;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="comment">//tmp指向下一个节点</span></span><br><span class="line">            <span class="type">ListNode</span> <span class="variable">tmp</span> <span class="operator">=</span> cur.next;</span><br><span class="line">            <span class="comment">//指针反向</span></span><br><span class="line">            cur.next = pre;</span><br><span class="line">            <span class="comment">//前进一步</span></span><br><span class="line">            pre = cur;</span><br><span class="line">            <span class="comment">//cur前进一步</span></span><br><span class="line">            cur = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="35-复杂链表的复制"><a href="#35-复杂链表的复制" class="headerlink" title="35.复杂链表的复制"></a>35.复杂链表的复制</h2><p><img src="/SwordOffer/35.png" alt="image-20220317133606574"></p>
<blockquote>
<p>思路：哈希表</p>
<p>利用哈希表的查询特点，考虑构建原链表节点和新链表对应节点的键值对映射关系，再遍历构建新链表各节点的next和random引用指向即可</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Definition for a Node.</span></span><br><span class="line"><span class="comment">class Node &#123;</span></span><br><span class="line"><span class="comment">    int val;</span></span><br><span class="line"><span class="comment">    Node next;</span></span><br><span class="line"><span class="comment">    Node random;</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">    public Node(int val) &#123;</span></span><br><span class="line"><span class="comment">        this.val = val;</span></span><br><span class="line"><span class="comment">        this.next = null;</span></span><br><span class="line"><span class="comment">        this.random = null;</span></span><br><span class="line"><span class="comment">    &#125;</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">copyRandomList</span><span class="params">(Node head)</span> &#123;</span><br><span class="line">    	<span class="keyword">if</span> (head == <span class="literal">null</span>) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="comment">//哈希表</span></span><br><span class="line">        Map&lt;Node, Node&gt; map = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head; cur != <span class="literal">null</span>; cur = cur.next) &#123;</span><br><span class="line">            map.put(cur, <span class="keyword">new</span> <span class="title class_">Node</span>(cur.val));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//将拷贝的新的节点组成一个链表</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">Node</span> <span class="variable">cur</span> <span class="operator">=</span> head; cur != <span class="literal">null</span>; cur = cur.next) &#123;</span><br><span class="line">            map.get(cur).next = map.get(cur.next);</span><br><span class="line">            map.get(cur).random = map.get(cur.random);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> map.get(head);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-替换空格"><a href="#5-替换空格" class="headerlink" title="5.替换空格"></a>5.替换空格</h2><p><img src="/SwordOffer/5.png" alt="image-20220318094918219"></p>
<blockquote>
<p>思路：遍历添加</p>
<p>在Java&#x2F;Python等语言中，字符串都被设计成不可变的类型，即无法直接修改字符串的某一位字符，需要新建一个字符串实现。</p>
<ul>
<li>初始化一个<code>StringBuilder</code></li>
<li>遍历列表s中的每个字符<ul>
<li>当c为空格时：向res后添加字符串”%20”</li>
<li>当c不为空格时：向res后添加字符c</li>
</ul>
</li>
<li>将列表res转化为字符串并返回</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">replaceSpace</span><span class="params">(String s)</span> &#123;</span><br><span class="line">		<span class="type">StringBuilder</span> <span class="variable">sb</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;s.length(); i++) &#123;</span><br><span class="line">            <span class="type">char</span> <span class="variable">c</span> <span class="operator">=</span> s.charAt(i);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>) sb.append(<span class="string">&quot;%20&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span> sb.append(c);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sb.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="58-左旋转字符串"><a href="#58-左旋转字符串" class="headerlink" title="58.左旋转字符串"></a>58.左旋转字符串</h2><p><img src="/SwordOffer/58.png" alt="image-20220318095235462"></p>
<blockquote>
<p>思路：字符串切片&#x2F;列表遍历拼接&#x2F;字符串遍历拼接</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseLeftWords</span><span class="params">(String s, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="comment">//public String substring(int beginIndex)</span></span><br><span class="line">        <span class="comment">//public String substring(int beginIndex, int endIndex)</span></span><br><span class="line">        <span class="comment">//字符串切片</span></span><br><span class="line">		<span class="comment">//return s.substring(n) + s.substring(0, n);        </span></span><br><span class="line">        <span class="comment">//列表遍历拼接</span></span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=n; i&lt;s.length(); i++)</span><br><span class="line">            res.append(s.charAt(i));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            res.append(s.charAt(i));</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-数组中重复的数字"><a href="#3-数组中重复的数字" class="headerlink" title="3.数组中重复的数字"></a>3.数组中重复的数字</h2><p><img src="/SwordOffer/3.png" alt="image-20220320223654399"></p>
<blockquote>
<p>思路：遍历数组</p>
<p>由于只需要找出数组中任意一个重复的数字，因此遍历数组，遇到重复的数字即返回。为了判断一个数字是否重复遇到，使用集合存储已经遇到的数字，如果遇到的一个数字已经在集合中，则当前数字是重复数字。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">findRepeatNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">		<span class="type">int</span>[] arr = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; nums.length; i++)&#123;</span><br><span class="line">            arr[nums[i]]++;</span><br><span class="line">            <span class="keyword">if</span>(arr[nums[i]] &gt; <span class="number">1</span>) <span class="keyword">return</span> nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="53-在排序数组中查找数字"><a href="#53-在排序数组中查找数字" class="headerlink" title="53.在排序数组中查找数字"></a>53.在排序数组中查找数字</h2><p><img src="/SwordOffer/53.png" alt="image-20220320224849123"></p>
<blockquote>
<p>思路：二分查找</p>
<p>直观的思路肯定是从前往后遍历一遍。用两个变量记录第一次和最后一次遇见 target 的下标，但这个方法的时间复杂度为 O(n)，没有利用到数组<strong>升序排列</strong>的条件。</p>
<p>由于数组已经排序，因此整个数组是<strong>单调递增</strong>的，我们可以利用二分法来加速查找的过程。</p>
<p>要求统计数字target的出现次数，可转化为：使用二分法分别找到左边界和右边界</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> <span class="number">0</span>, right = nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">count</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">mid</span> <span class="operator">=</span> (left+right)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid]&gt;=target) right=mid;</span><br><span class="line">            <span class="keyword">if</span> (nums[mid]&lt;target) left=mid+<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (left&lt;nums.length&amp;&amp;nums[left++]==target) count++;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="53-0-n-1中缺失的数字"><a href="#53-0-n-1中缺失的数字" class="headerlink" title="53.0~n-1中缺失的数字"></a>53.0~n-1中缺失的数字</h2><p><img src="/SwordOffer/53_2.png" alt="image-20220321093634050"></p>
<blockquote>
<p>思路：排序数组的搜索问题，首先想到<strong>二分法</strong>解决</p>
<p>根据题意，数组可以按照以下规则划分为两部分</p>
<ul>
<li>左子数组：<code>nums[i] = i</code></li>
<li>右子数组：<code>nums[i] ≠ i</code></li>
</ul>
<p>缺失的数字等于<strong>右子数组的首位元素</strong>对应的索引；因此考虑二分法查找右子数组的首位元素</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">missingNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>, j=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;=j) &#123;</span><br><span class="line">            <span class="type">int</span> m=(i+j)/<span class="number">2</span>;	<span class="comment">//计算中点</span></span><br><span class="line">            <span class="keyword">if</span> (nums[m] == m) i = m+<span class="number">1</span>;	<span class="comment">//右子数组的首位元素 一定在区间[m+1, j]中，因此执行i=m+1</span></span><br><span class="line">            <span class="keyword">else</span> j = m-<span class="number">1</span>;	<span class="comment">//左子数组的末尾元素 一定在区间[i,m-1]中，因此执行j=m-1</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;	<span class="comment">//跳出时，变量i和j分别指向 右子数组的首位元素 和 左子数组的末位元素。因此返回i即可</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-二维数组中的查找"><a href="#4-二维数组中的查找" class="headerlink" title="4.二维数组中的查找"></a>4.二维数组中的查找</h2><p><img src="/SwordOffer/4.png" alt="image-20220322224247970"></p>
<blockquote>
<p>思路：利用<strong>从上到下递增，从左到右递增</strong>的特点</p>
<p>将矩阵逆时针旋转45°，并将其转化为图形式，其类似于<strong>二叉搜索树</strong></p>
<p>通过从“根节点”开始搜索，遇到比<code>target</code>大的元素就向左，反之向右，即可找到目标值<code>target</code></p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">findNumberIn2DArray</span><span class="params">(<span class="type">int</span>[][] matrix, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">		<span class="type">int</span> i=matrix.length-<span class="number">1</span>, j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&gt;=<span class="number">0</span> &amp;&amp; j&lt;matrix[<span class="number">0</span>].length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (matrix[i][j] &gt; target) i--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (matrix[i][j] &lt; target) j++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="11-旋转数组的最小数字"><a href="#11-旋转数组的最小数字" class="headerlink" title="11.旋转数组的最小数字"></a>11.旋转数组的最小数字</h2><p><img src="/SwordOffer/11.png" alt="image-20220322224818422"></p>
<blockquote>
<p>思路：排序数组的查找问题首先考虑使用<strong>二分法</strong>解决</p>
<p>寻找旋转数组的最小元素即为寻找<strong>右排序数组</strong>的首个元素</p>
<ul>
<li>初始化：声明<code>i,j</code><strong>双指针</strong>分别指向<code>nums</code>数组左右两端</li>
<li>循环二分：设<code>m</code>为每次二分的中点，可分为以下三种情况<ul>
<li>当<code>nums[m] &gt; nums[j]</code>时：m一定在 左排序数组 中，即旋转点x一定在[m+1, j]闭区间内，因此执行<code>i=m+1</code></li>
<li>当<code>nums[m] &lt; nums[j]</code>时：m一定在 右排序数组 中，即旋转点x一定在[i, m]闭区间内，因此执行<code>j=m</code></li>
<li>当<code>nums[m] = nums[j]</code>时：无法判断m在哪个排序数组中，即无法判断旋转点x在[i,m]还是[m+1, j]闭区间内，因此缩小判断范围，执行<code>j=j-1</code></li>
</ul>
</li>
<li>返回值：当 <code>i=j</code> 时跳出二分循环，并返回 <strong>旋转点的值</strong> <code>nums[i]</code>即可</li>
</ul>
</blockquote>
<p><img src="/SwordOffer/11_2.png" alt="image-20220322230750006"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">minArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>, j = nums.length - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> (i + j) / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (nums[m] &gt; nums[j]) i=m+<span class="number">1</span>;	<span class="comment">//m在左序列中</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (nums[m] &lt; nums[j]) j = m;	<span class="comment">//m在右序列中</span></span><br><span class="line">            <span class="keyword">else</span> j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>补充思考：为什么本题二分法不用 nums[m]和nums[i] 作比较？</p>
<p>二分目的是判断 mm 在哪个排序数组中，从而缩小区间。而在nums[m]&gt;nums[i]情况下，无法判断m在哪个排序数组中。本质上是由于 j 初始值肯定在右排序数组中； i初始值无法确定在哪个排序数组中。</p>
</blockquote>
<h2 id="50-第一个只出现一次的字符"><a href="#50-第一个只出现一次的字符" class="headerlink" title="50.第一个只出现一次的字符"></a>50.第一个只出现一次的字符</h2><p><img src="/SwordOffer/50.png" alt="image-20220323094608551"></p>
<blockquote>
<p>思路：哈希表</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">char</span> <span class="title function_">firstUniqChar</span><span class="params">(String s)</span> &#123;</span><br><span class="line">		HashMap&lt;Character, Boolean&gt; dic = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">char</span>[] sc = s.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : sc)</span><br><span class="line">            dic.put(c, !dic.containsKey(c));</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : sc)</span><br><span class="line">            <span class="keyword">if</span> (dic.get(c)) <span class="keyword">return</span> c;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="32-1-从上到下打印二叉树"><a href="#32-1-从上到下打印二叉树" class="headerlink" title="32_1.从上到下打印二叉树"></a>32_1.从上到下打印二叉树</h2><p><img src="/SwordOffer/32-1.png" alt="image-20220323095407779"></p>
<blockquote>
<p>思路：从上到下打印，即按层打印。使用二叉树的<strong>广度优先搜索</strong></p>
<p><code>BFS</code>通常借助队列的先入先出特性来实现</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] levelOrder(TreeNode root) &#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;() &#123;&#123;add(root);&#125;&#125;;</span><br><span class="line">        ArrayList&lt;Integer&gt; ans = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="comment">//移出并返回队列头部的元素，如果队列为空，则返回null</span></span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            ans.add(node.val);</span><br><span class="line">            <span class="keyword">if</span> (node.left != <span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">            <span class="keyword">if</span> (node.right != <span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[ans.size()];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;ans.size(); i++)</span><br><span class="line">            res[i] = ans.get(i);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="32-2-从上到下打印二叉树"><a href="#32-2-从上到下打印二叉树" class="headerlink" title="32_2.从上到下打印二叉树"></a>32_2.从上到下打印二叉树</h2><p><img src="/SwordOffer/32-2.png" alt="image-20220323110229286"></p>
<blockquote>
<p>思路：将本层全部节点打印到一行，并将下一层全部节点加入队列，以此类推，即可分为多行打印</p>
<ul>
<li>BFS循环<ol>
<li>新建一个临时列表，用于存储当前层打印结果</li>
<li>当前层打印循环</li>
<li>将当前层结果添加入<code>res</code></li>
</ol>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">		Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            List&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=queue.size(); i&gt;<span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                tmp.add(node.val);</span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="32-3-从上到下打印二叉树"><a href="#32-3-从上到下打印二叉树" class="headerlink" title="32_3.从上到下打印二叉树"></a>32_3.从上到下打印二叉树</h2><p><img src="/SwordOffer/32-3.png" alt="image-20220323111010622"></p>
<blockquote>
<p>思路：层序遍历+双端队列</p>
<p>利用双端队列的两端皆可添加元素的特性，设打印列表(双端队列)<code>tmp</code>，并规定</p>
<ul>
<li>奇数层 添加到<code>tmp</code>尾部</li>
<li>偶数层 添加到<code>tmp</code>头部</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">levelOrder</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">		Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        List&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">if</span>(root != <span class="literal">null</span>) queue.add(root);</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            LinkedList&lt;Integer&gt; tmp = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i=queue.size(); i&gt;<span class="number">0</span>; i--) &#123;</span><br><span class="line">                <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">                <span class="keyword">if</span> (res.size() % <span class="number">2</span> == <span class="number">0</span>) tmp.addLast(node.val);	<span class="comment">//偶数层-&gt;队列头部</span></span><br><span class="line">                <span class="keyword">else</span> tmp.addFirst(node.val);	<span class="comment">//奇数层-&gt;队列尾部</span></span><br><span class="line">                <span class="keyword">if</span> (node.left != <span class="literal">null</span>) queue.add(node.left);</span><br><span class="line">                <span class="keyword">if</span> (node.right != <span class="literal">null</span>) queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.add(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="26-树的子结构"><a href="#26-树的子结构" class="headerlink" title="26.树的子结构"></a>26.树的子结构</h2><blockquote>
<p>思路：若树B是树A的子结构，则子结构的根节点可能为树A的任意一个节点。因此，判断树B是否是树A的子结构，需要完成以下两步工作</p>
<ol>
<li>先遍历树A中每个节点a</li>
<li>判断树A中以a为根节点的子树是否包含树B</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSubStructure</span><span class="params">(TreeNode A, TreeNode B)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> (A!=<span class="literal">null</span> &amp;&amp; B!=<span class="literal">null</span>) &amp;&amp; (recur(A, B) || isSubStructure(A.left, B) || isSubStructure(A.right, B));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">recur</span><span class="params">(TreeNode A, TreeNode B)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (B == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span> (A == <span class="literal">null</span> || A.val != B.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> recur(A.left, B.left) &amp;&amp; recur(A.right, B.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="27-二叉树的镜像"><a href="#27-二叉树的镜像" class="headerlink" title="27.二叉树的镜像"></a>27.二叉树的镜像</h2><blockquote>
<p>思路：递归法</p>
<p>根据定义，递归遍历二叉树，交换每个节点的左右子节点，即可生成二叉树的镜像</p>
<ol>
<li>终止条件：当节点<code>root</code>为空时，则返回<code>null</code></li>
<li>递推工作<ol>
<li>初始化节点<code>tmp</code>，用于暂存<code>root</code>的左子节点</li>
<li>开启递归右子节点，并将返回值作为<code>root</code>的左子节点</li>
<li>开启递归左子节点，并将返回值作为<code>root</code>的右子节点</li>
</ol>
</li>
<li>返回值：返回当前节点<code>root</code></li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">mirrorTree</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">tmp</span> <span class="operator">=</span> root.left;</span><br><span class="line">        root.left = mirrorTree(root.right);</span><br><span class="line">        root.right = mirrorTree(tmp);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="28-对称的二叉树"><a href="#28-对称的二叉树" class="headerlink" title="28.对称的二叉树"></a>28.对称的二叉树</h2><blockquote>
<p>思路：从顶至底递归判断</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isSymmetric</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">		<span class="type">return</span> <span class="variable">root</span> <span class="operator">=</span>= <span class="literal">null</span> ? <span class="literal">true</span> : recur(root.left, root.right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">recur</span><span class="params">(TreeNode L, TreeNode R)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(L == <span class="literal">null</span> &amp;&amp; R == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(L == <span class="literal">null</span> || R == <span class="literal">null</span> || L.val != R.val) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> recur(L.left, R.right) &amp;&amp; recur(L.right, R.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-1-斐波那契数列"><a href="#10-1-斐波那契数列" class="headerlink" title="10_1.斐波那契数列"></a>10_1.斐波那契数列</h2><p><img src="/SwordOffer/10-1.png" alt="image-20220324133705521"></p>
<blockquote>
<p>思路：</p>
<ol>
<li>动态规划：最佳解法</li>
<li>递归：大量重复的递归计算</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">fib</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="type">int</span> <span class="variable">MOD</span> <span class="operator">=</span> <span class="number">1000000007</span>;</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> <span class="variable">p</span> <span class="operator">=</span> <span class="number">0</span>, q = <span class="number">0</span>, r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            p = q; </span><br><span class="line">            q = r; </span><br><span class="line">            r = (p + q) % MOD;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="10-2-青蛙跳台阶问题"><a href="#10-2-青蛙跳台阶问题" class="headerlink" title="10_2.青蛙跳台阶问题"></a>10_2.青蛙跳台阶问题</h2><p><img src="/SwordOffer/10-2.png" alt="image-20220324135825095"></p>
<blockquote>
<p>思路：动态规划</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">numWays</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">a</span> <span class="operator">=</span> <span class="number">1</span>, b = <span class="number">1</span>, sum;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; n; i++)&#123;</span><br><span class="line">            sum = (a + b) % <span class="number">1000000007</span>;</span><br><span class="line">            a = b;</span><br><span class="line">            b = sum;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="63-股票的最大利润"><a href="#63-股票的最大利润" class="headerlink" title="63.股票的最大利润"></a>63.股票的最大利润</h2><p><img src="/SwordOffer/63.png" alt="image-20220324141414661"></p>
<blockquote>
<p>思路：动态规划</p>
<ul>
<li>状态定义：设动态规划列表<code>dp</code>，<code>dp[i]</code>代表以<code>price[i]</code>为结尾的子数组的最大利润</li>
<li>转移方程：由于限定“买卖该股票一次”，因此前<code>i</code>日最大利润<code>dp[i]</code>等于前<code>i-1</code>日最大利润<code>dp[i-1]</code>和第<code>i</code>日卖出的最大利润中的最大值</li>
<li>初始状态：<code>dp[0]=0</code>，即首日利润为0</li>
<li>返回值：<code>dp[n-1]</code>，其中<code>n</code>为<code>dp</code>列表长度</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxProfit</span><span class="params">(<span class="type">int</span>[] prices)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">cost</span> <span class="operator">=</span> Integer.MAX_VALUE, profit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> price : prices) &#123;</span><br><span class="line">            cost = Math.min(cost, price);</span><br><span class="line">            profit = Math.max(profit, price - cost);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> profit;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="42-连续子数组的最大和"><a href="#42-连续子数组的最大和" class="headerlink" title="42.连续子数组的最大和"></a>42.连续子数组的最大和</h2><p><img src="/SwordOffer/42.png" alt="image-20220324142018725"></p>
<blockquote>
<p>思路：动态规划</p>
<ul>
<li>状态定义：<code>dp[i]</code>代表以元素<code>nums[i]</code>为结尾的连续子数组最大和</li>
<li>转移方程：若<code>dp[i-1]&lt;=0</code>，说明<code>dp[i-1]</code>对<code>dp[i]</code>产生负贡献，即<code>dp[i-1]+nums[i]</code>还不如<code>nums[i]</code>本身大</li>
<li>初始状态：<code>dp[0]=nums[0]</code>，即以<code>nums[0]</code>结尾的连续子数组最大和为<code>nums[0]</code></li>
<li>返回值：返回<code>dp</code>列表中的最大值，即全局最大值</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxSubArray</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> nums[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">former</span> <span class="operator">=</span> <span class="number">0</span>;	<span class="comment">//用于记录dp[i-1]的值，对于dp[0]而言，其前面的dp[-1]=0</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">cur</span> <span class="operator">=</span> nums[<span class="number">0</span>];	<span class="comment">//用于记录dp[i]的值</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums) &#123;</span><br><span class="line">            cur = num;</span><br><span class="line">            cur += Math.max(former, <span class="number">0</span>);</span><br><span class="line">            res = Math.max(res, cur);</span><br><span class="line">            former = cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="47-礼物的最大价值"><a href="#47-礼物的最大价值" class="headerlink" title="47.礼物的最大价值"></a>47.礼物的最大价值</h2><p><img src="/SwordOffer/47.png" alt="image-20220324144141260"></p>
<blockquote>
<p>思路：动态规划</p>
<p>单元格只可能从上边或左边到达</p>
<ul>
<li>状态定义：<code>dp(i,j)</code>代表从棋盘的左上角开始，到达单元格<code>(i,j)</code>时能拿到礼物的最大累计价值</li>
<li>转移方程：四种情况</li>
<li>初始状态：<code>dp[0][0]=price[0][0]</code></li>
<li>返回值：<code>dp[m-1][n-1]</code></li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxValue</span><span class="params">(<span class="type">int</span>[][] grid)</span> &#123;</span><br><span class="line">	<span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> grid.length, n = grid[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; n; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span> &amp;&amp; j == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>) grid[i][j] += grid[i][j - <span class="number">1</span>] ;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(j == <span class="number">0</span>) grid[i][j] += grid[i - <span class="number">1</span>][j];</span><br><span class="line">                <span class="keyword">else</span> grid[i][j] += Math.max(grid[i][j - <span class="number">1</span>], grid[i - <span class="number">1</span>][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[m-<span class="number">1</span>][n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="46-把数字翻译成字符串"><a href="#46-把数字翻译成字符串" class="headerlink" title="46. 把数字翻译成字符串"></a>46. 把数字翻译成字符串</h2><p><img src="/SwordOffer/46.png" alt="image-20220325113836843"></p>
<p><img src="/SwordOffer/46_1.png" alt="Picture1.png"></p>
<blockquote>
<p>思路：动态规划</p>
<ul>
<li>状态定义：<code>dp[i]</code>代表以<code>Xi</code>为结尾的数字的翻译方案数量</li>
<li>转移方程：若<code>Xi</code>和<code>Xi-1</code>组成的两位数字可以被翻译，则<code>dp[i]=dp[i-1]+dp[i-2]</code>；否则<code>dp[i]=dp[i-1]</code></li>
<li>初始状态：<code>dp[0]=dp[1]=1</code></li>
<li>返回值：<code>dp[n]</code>，即此数字的翻译方案数量</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">translateNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">		<span class="comment">//字符串遍历</span></span><br><span class="line">        <span class="type">String</span> <span class="variable">s</span> <span class="operator">=</span> String.valueOf(num);</span><br><span class="line">        <span class="type">int</span> a=<span class="number">1</span>, b=<span class="number">1</span>;	<span class="comment">//空间优化</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">2</span>; i&lt;=s.length(); i++) &#123;</span><br><span class="line">            <span class="type">String</span> <span class="variable">tmp</span> <span class="operator">=</span> s.substring(i-<span class="number">2</span>, i);</span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> tmp.compareTo(<span class="string">&quot;10&quot;</span>) &gt;= <span class="number">0</span> &amp;&amp; tmp.compareTo(<span class="string">&quot;25&quot;</span>) &lt;= <span class="number">0</span> ? a + b : b;</span><br><span class="line">            a = b;</span><br><span class="line">            b = c;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="48-最长不含重复字符的子字符串"><a href="#48-最长不含重复字符的子字符串" class="headerlink" title="48.最长不含重复字符的子字符串"></a>48.最长不含重复字符的子字符串</h2><p><img src="/SwordOffer/48.png" alt="image-20220325132529375"></p>
<blockquote>
<p>思路：动态规划降低时间复杂度</p>
<p>使用暴力法时间复杂度N^3</p>
<ul>
<li>状态定义：<code>dp[j]</code>代表以字符<code>s[j]</code>为结尾的“最长不重复子字符串”的长度</li>
<li>转移方程：固定右边界<code>j</code>，设字符<code>s[j]</code>左边距离最近的相同字符为<code>s[i]</code>，即<code>s[i]=s[j]</code><ul>
<li>当 i &lt; 0，即<code>s[j]</code>左边无相同字符，则 <code>dp[j] = dp[j-1] + 1</code>；</li>
<li>当<code>dp[j - 1] &lt; j - i</code>，说明字符s[i]在子字符串<code>dp[j-1]</code>区间之外 ，则<code>dp[j]=dp[j-1]+1</code>；</li>
<li>当<code>dp[j−1]≥j−i</code>，说明字符 s[i]在子字符串 <code>dp[j-1]</code>区间之中 ，则<code>dp[j]</code>的左边界由<code>s[i]</code>决定，即 <code>dp[j] = j - i</code>；</li>
</ul>
</li>
<li>返回值：<code>max(dp)</code>，即全局“最长不重复子字符串”的长度</li>
<li><img src="/SwordOffer/48_1.png" alt="Picture1.png"></li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">		Map&lt;Character, Integer&gt; dic = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>, tmp = <span class="number">0</span>;	<span class="comment">//空间复杂度优化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; s.length(); j++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> dic.getOrDefault(s.charAt(j), -<span class="number">1</span>); 	<span class="comment">//获取索引i</span></span><br><span class="line">            dic.put(s.charAt(j), j);		<span class="comment">//更新哈希表</span></span><br><span class="line">            tmp = tmp &lt; j-i ? tmp + <span class="number">1</span> : j - i;	<span class="comment">//dp[j-1] -&gt; dp[j]</span></span><br><span class="line">            res = Math.max(res, tmp);		<span class="comment">// max(dp[j - 1], dp[j])</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>思路：<strong>双指针 + 哈希表</strong></p>
<ul>
<li>哈希表统计字符<code>s[j]</code>最后一次出现的索引</li>
<li>根据上轮左指针<code>i</code>和<code>dic[s[j]]</code>，每轮更新左边界<code>i</code>，保证区间<code>[i+1,j]</code>内无重复字符且最大</li>
<li>更新结果</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lengthOfLongestSubstring</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        Map&lt;Character, Integer&gt; dic = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> -<span class="number">1</span>, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> <span class="number">0</span>; j &lt; s.length(); j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(dic.containsKey(s.charAt(j)))</span><br><span class="line">                i = Math.max(i, dic.get(s.charAt(j))); <span class="comment">// 更新左指针 i</span></span><br><span class="line">            dic.put(s.charAt(j), j); <span class="comment">// 哈希表记录</span></span><br><span class="line">            res = Math.max(res, j - i); <span class="comment">// 更新结果</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="18-删除链表的节点"><a href="#18-删除链表的节点" class="headerlink" title="18.删除链表的节点"></a>18.删除链表的节点</h2><p><img src="/SwordOffer/18.png" alt="image-20220326102942907"></p>
<blockquote>
<p>思路：双指针</p>
<p>删除节点需要两步：定位节点、修改引用</p>
<ol>
<li>定位节点：遍历链表，直到<code>head.val == val</code>时跳出，即可定位目标节点</li>
<li>修改引用：设节点<code>cur</code>的前驱节点为<code>pre</code>，后继节点为<code>cur.next</code>；则执行<code>pre.next=cur.next</code>，即可实现删除<code>cur</code>节点</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">deleteNode</span><span class="params">(ListNode head, <span class="type">int</span> val)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (head.val == val) <span class="keyword">return</span> head.next;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">pre</span> <span class="operator">=</span> head, cur = head.next;</span><br><span class="line">        <span class="keyword">while</span> (cur != <span class="literal">null</span> &amp;&amp; cur.val != val) &#123;</span><br><span class="line">            pre = cur;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (cur != <span class="literal">null</span>) pre.next = cur.next;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="22-链表中倒数第k个节点"><a href="#22-链表中倒数第k个节点" class="headerlink" title="22.链表中倒数第k个节点"></a>22.链表中倒数第k个节点</h2><p><img src="/SwordOffer/22.png" alt="image-20220326104017085"></p>
<blockquote>
<p>思路：双指针</p>
<p>使用双指针可以不用统计链表长度</p>
<ol>
<li>初始化：双指针都指向头节点</li>
<li>构建双指针距离：前指针先向前走<code>k</code>步</li>
<li>双指针共同移动：循环中，双指针每轮都向前走一步，直至前指针走过链表尾结点时跳出循环。此时，后指针与尾结点距离<code>k-1</code>，即后指针指向倒数第<code>k</code>个节点</li>
<li>返回值：返回后指针即可</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getKthFromEnd</span><span class="params">(ListNode head, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">		<span class="type">ListNode</span> <span class="variable">former</span> <span class="operator">=</span> head, latter = head;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; k; i++)</span><br><span class="line">            former = former.next;</span><br><span class="line">        <span class="keyword">while</span>(former != <span class="literal">null</span>) &#123;</span><br><span class="line">            former = former.next;</span><br><span class="line">            latter = latter.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> latter;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="25-合并两个排序的链表"><a href="#25-合并两个排序的链表" class="headerlink" title="25.合并两个排序的链表"></a>25.合并两个排序的链表</h2><p><img src="/SwordOffer/25.png" alt="image-20220327110656807"></p>
<blockquote>
<p>思路：双指针</p>
<ol>
<li>初始化：伪头节点，节点cur指向<code>dum</code></li>
<li>循环合并：当<code>l1</code>或<code>l2</code>为空时跳出</li>
<li>合并剩余尾部</li>
<li>返回值：合并链表在伪节点<code>dum</code>之后，因此返回<code>dum.next</code>即可</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">mergeTwoLists</span><span class="params">(ListNode l1, ListNode l2)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">dum</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">ListNode</span>(<span class="number">0</span>), cur = dum;</span><br><span class="line">        <span class="keyword">while</span> (l1 != <span class="literal">null</span> &amp;&amp; l2 != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (l1.val &lt; l2.val) &#123;</span><br><span class="line">                cur.next = l1;</span><br><span class="line">                l1 = l1.next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                cur.next = l2;</span><br><span class="line">                l2 = l2.next;</span><br><span class="line">            &#125;</span><br><span class="line">            cur = cur.next;</span><br><span class="line">        &#125;</span><br><span class="line">        cur.next = l1 != <span class="literal">null</span> ? l1 : l2;</span><br><span class="line">        <span class="keyword">return</span> dum.next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="52-两个链表的第一个公共节点"><a href="#52-两个链表的第一个公共节点" class="headerlink" title="52.两个链表的第一个公共节点"></a>52.两个链表的第一个公共节点</h2><p><img src="/SwordOffer/52.png" alt="image-20220327110829126"></p>
<blockquote>
<p>思路：双指针</p>
<p><code>headA</code>的节点数量为<code>a</code>，<code>headB</code>的节点数量为<code>b</code>，两链表的公共尾部的节点数量<code>c</code>，则有</p>
<ul>
<li>头节点<code>headA</code>到<code>node</code>前，共有<code>a-c</code>个节点</li>
<li>头节点<code>headB</code>到<code>node</code>前，共有<code>b-c</code>个节点</li>
</ul>
<p>指针A遍历完链表A再遍历链表B，指针B遍历完链表B再遍历链表A，当指针A和B重合时，若不指向<code>null</code>，则为目标节点</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> ListNode <span class="title function_">getIntersectionNode</span><span class="params">(ListNode headA, ListNode headB)</span> &#123;</span><br><span class="line">        <span class="type">ListNode</span> <span class="variable">A</span> <span class="operator">=</span> headA, B = headB;</span><br><span class="line">        <span class="keyword">while</span> (A != B) &#123;</span><br><span class="line">            A = A != <span class="literal">null</span> ? A.next : headB;</span><br><span class="line">            B = B != <span class="literal">null</span> ? B.next : headA;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> A;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="21-调整数组顺序使奇数位于偶数前面"><a href="#21-调整数组顺序使奇数位于偶数前面" class="headerlink" title="21.调整数组顺序使奇数位于偶数前面"></a>21.调整数组顺序使奇数位于偶数前面</h2><p><img src="/SwordOffer/21.png" alt="image-20220328113226279"></p>
<blockquote>
<p>思路：双指针</p>
<p>双指针分列数组左右两端，循环执行：</p>
<ol>
<li>指针i从左往右寻找偶数</li>
<li>指针j从右往左寻找奇数</li>
<li>将偶数<code>nums[i]</code>和奇数<code>nums[j]</code>交换</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] exchange(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">		<span class="type">int</span> i=<span class="number">0</span>, j=nums.length - <span class="number">1</span>, tmp;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;j) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;j &amp;&amp; (nums[i] &amp; <span class="number">1</span>) == <span class="number">1</span>) i++;</span><br><span class="line">            <span class="keyword">while</span> (i&lt;j &amp;&amp; (nums[j] &amp; <span class="number">1</span>) == <span class="number">0</span>) j--;</span><br><span class="line">            tmp = nums[i];</span><br><span class="line">            nums[i] = nums[j];</span><br><span class="line">            nums[j] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="57-和为s的两个数字"><a href="#57-和为s的两个数字" class="headerlink" title="57.和为s的两个数字"></a>57.和为s的两个数字</h2><p><img src="/SwordOffer/57..png" alt="image-20220328113807235"></p>
<blockquote>
<p>思路：双指针</p>
<p>利用<strong>排序数组</strong>的条件，使用双指针将空间复杂度降至O(1)</p>
<ol>
<li>初始化：双指针位于数组左右两端</li>
<li>循环搜索：当双指针相遇时跳出</li>
<li>返回空数组，代表无和为<code>target</code>的数字组合</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] twoSum(<span class="type">int</span>[] nums, <span class="type">int</span> target) &#123;</span><br><span class="line">		<span class="type">int</span> i=<span class="number">0</span>, j=nums.length-<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i&lt;j) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">s</span> <span class="operator">=</span> nums[i]+nums[j];</span><br><span class="line">            <span class="keyword">if</span> (s&lt;target) i++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (s&gt;target) j--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[] &#123;nums[i], nums[j]&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="58-1-翻转单词顺序"><a href="#58-1-翻转单词顺序" class="headerlink" title="58_1.翻转单词顺序"></a>58_1.翻转单词顺序</h2><p><img src="/SwordOffer/58_1.png" alt="image-20220328123309870"></p>
<blockquote>
<p>思路：双指针</p>
<ul>
<li>倒序遍历字符串<code>s</code>，记录单词左右索引边界<code>i,j</code></li>
<li>每确定一个单词的边界，则将其添加至单词列表<code>res</code></li>
<li>最终，将单词列表拼接为字符串，并返回即可</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">reverseWords</span><span class="params">(String s)</span> &#123;</span><br><span class="line">		s = s.trim();</span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> s.length()-<span class="number">1</span>, i=j;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">while</span> (i&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (i&gt;=<span class="number">0</span> &amp;&amp; s.charAt(i) != <span class="string">&#x27; &#x27;</span>) i--;	<span class="comment">//搜索首个空格</span></span><br><span class="line">            res.append(s.substring(i+<span class="number">1</span>, j+<span class="number">1</span>)+<span class="string">&quot; &quot;</span>);  <span class="comment">//添加单词</span></span><br><span class="line">            <span class="keyword">while</span> (i&gt;=<span class="number">0</span> &amp;&amp; s.charAt(i) == <span class="string">&#x27; &#x27;</span>) i--;	<span class="comment">//跳过单词间空格</span></span><br><span class="line">            j = i;		<span class="comment">//j指向下一个单词的尾字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toString().trim();	<span class="comment">//转化为字符串并返回</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="12-矩阵中的路径"><a href="#12-矩阵中的路径" class="headerlink" title="12.矩阵中的路径"></a>12.矩阵中的路径</h2><p><img src="/SwordOffer/12.png" alt="image-20220329132107365"></p>
<blockquote>
<p>思路：深度优先搜索+剪枝</p>
<ul>
<li>递归参数：当前元素在矩阵<code>board</code>中的行列索引<code>i</code>和<code>j</code>，当前目标字符在<code>word</code>中的索引<code>k</code></li>
<li>终止条件<ol>
<li>返回false：行或列索引越界；当前矩阵元素与目标字符不同；当前元素已访问过</li>
<li>返回true:<code>k=len(word)-1</code>，即当前字符串<code>word</code>已全部匹配</li>
</ol>
</li>
<li>递推工作<ol>
<li>标记当前矩阵元素：将<code>board[i][j]</code>修改为空字符，代表已经访问过</li>
<li>搜索下一单元格：朝当前元素的上下左右四个方向开启下层递归，使用或连接，并记录结果至<code>res</code></li>
<li>还原当前矩阵元素：将<code>board[i][j]</code>元素还原至初始值</li>
</ol>
</li>
<li>返回值：返回布尔量<code>res</code>，代表是否搜索到目标字符串</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">exist</span><span class="params">(<span class="type">char</span>[][] board, String word)</span> &#123;</span><br><span class="line">		<span class="type">char</span>[] words = word.toCharArray();</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;board.length; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;board[<span class="number">0</span>].length; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (dfs(board, words, i, j, <span class="number">0</span>)) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">dfs</span><span class="params">(<span class="type">char</span>[][] board, <span class="type">char</span>[] word, <span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(i &gt;= board.length || i &lt; <span class="number">0</span> || j &gt;= board[<span class="number">0</span>].length || j &lt; <span class="number">0</span> || board[i][j] != word[k]) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(k == word.length - <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        board[i][j] = <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">        <span class="type">boolean</span> <span class="variable">res</span> <span class="operator">=</span> dfs(board, word, i + <span class="number">1</span>, j, k + <span class="number">1</span>) || dfs(board, word, i - <span class="number">1</span>, j, k + <span class="number">1</span>) || dfs(board, word, i, j + <span class="number">1</span>, k + <span class="number">1</span>) || dfs(board, word, i , j - <span class="number">1</span>, k + <span class="number">1</span>);</span><br><span class="line">        board[i][j] = word[k];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="13-机器人的运动范围"><a href="#13-机器人的运动范围" class="headerlink" title="13.机器人的运动范围"></a>13.机器人的运动范围</h2><p><img src="/SwordOffer/13.png" alt="image-20220329132205453"></p>
<blockquote>
<p>思路：搜索与回溯-深度优先遍历</p>
<ul>
<li>递归参数：当前元素在矩阵中的行列索引<code>i</code>和<code>j</code>，两者的数位和<code>si,sj</code></li>
<li>终止条件：<ol>
<li>行列索引越界</li>
<li>数位和超出目标值</li>
<li>当前元素已经访问过</li>
</ol>
</li>
<li>递推工作：<ol>
<li>标记当前单元格：将索引<code>(i,j)</code>存入<code>visited</code>中，代表此单元格已经被访问</li>
<li>搜索下一单元格：计算当前元素的下、右两个方向元素的数位和，并开启下层递归</li>
</ol>
</li>
<li>回溯返回值：返回<code>1+右方搜索的可达解总数+下方搜索的可达解总数</code>,代表从本单元格递归搜索的可达解总数</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> m, n, k;</span><br><span class="line">    <span class="type">boolean</span>[][] visited;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">movingCount</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.m = m; <span class="built_in">this</span>.n = n; <span class="built_in">this</span>.k = k;</span><br><span class="line">        <span class="built_in">this</span>.visited = <span class="keyword">new</span> <span class="title class_">boolean</span>[m][n];</span><br><span class="line">        <span class="keyword">return</span> dfs(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> i, <span class="type">int</span> j, <span class="type">int</span> si, <span class="type">int</span> sj)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i&gt;=m || j&gt;=n || k&lt;si+sj || visited[i][j]) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        visited[i][j] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>+dfs(i+<span class="number">1</span>, j, (i+<span class="number">1</span>)%<span class="number">10</span> != <span class="number">0</span> ? si+<span class="number">1</span> : si-<span class="number">8</span>, sj) + dfs(i, j+<span class="number">1</span>, si, (j+<span class="number">1</span>)%<span class="number">10</span> != <span class="number">0</span> ? sj+<span class="number">1</span> : sj-<span class="number">8</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="34-二叉树中和为某一值的路径"><a href="#34-二叉树中和为某一值的路径" class="headerlink" title="34.二叉树中和为某一值的路径"></a>34.二叉树中和为某一值的路径</h2><p><img src="/SwordOffer/34.png" alt="image-20220331124230620"></p>
<blockquote>
<p>思路：先序遍历+路径记录</p>
<ul>
<li>初始化：结果列表<code>res</code>，路径列表<code>path</code></li>
<li>返回值：返回<code>res</code>即可</li>
<li>递推工作：<ol>
<li>路径更新：将当前节点值<code>root.val</code>加入路径<code>path</code></li>
<li>目标值更新：<code>tar = tar-root.val</code></li>
<li>路径记录：当<code>root</code>为叶节点且路径和等于目标值，则将此路径<code>path</code>加入<code>res</code></li>
<li>先序遍历：递归左右子节点</li>
<li>路径恢复：向上回溯前，需将当前节点从路径<code>path</code>中删除</li>
</ol>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    LinkedList&lt;List&lt;Integer&gt;&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    LinkedList&lt;Integer&gt; path = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> List&lt;List&lt;Integer&gt;&gt; <span class="title function_">pathSum</span><span class="params">(TreeNode root, <span class="type">int</span> target)</span> &#123;</span><br><span class="line">		recur(root, sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">recur</span><span class="params">(TreeNode root, <span class="type">int</span> tar)</span> &#123; </span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> ;</span><br><span class="line">        path.add(root.val);</span><br><span class="line">        tar -= root.val;</span><br><span class="line">        <span class="keyword">if</span> (tar == <span class="number">0</span> &amp;&amp; root.left == <span class="literal">null</span> &amp;&amp; root.right == <span class="literal">null</span>)</span><br><span class="line">            res.add(<span class="keyword">new</span> <span class="title class_">LinkedList</span>(path));</span><br><span class="line">        recur(root.left, tar);</span><br><span class="line">        recur(root.right, tar);</span><br><span class="line">        path.removeLast();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="36-二叉搜索树与双向链表"><a href="#36-二叉搜索树与双向链表" class="headerlink" title="36.二叉搜索树与双向链表"></a>36.二叉搜索树与双向链表</h2><p><img src="/SwordOffer/36.png" alt="image-20220331124411503"></p>
<blockquote>
<p>思路：中序遍历</p>
<p>使用中序遍历访问树的各节点<code>cur</code>；并在访问每个节点时构建<code>cur</code>和前驱节点<code>pre</code>的引用指向；中序遍历完成后，最后构建头节点和尾节点的引用指向即可</p>
<ol>
<li>终止条件：当节点<code>cur</code>为空，代表越过叶节点，直接返回</li>
<li>递归左子树</li>
<li>构建链表：<ol>
<li>当<code>pre</code>为空时：代表正在访问链表头节点，记为<code>head</code></li>
<li>当<code>pre</code>不为空时：修改双向节点引用，即<code>pre.right=cur, cur.left=pre</code></li>
<li>保存<code>cur</code>:更新<code>pre=cur</code>，即节点<code>cur</code>是后继节点的<code>pre</code></li>
</ol>
</li>
<li>递归右子树</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    Node pre, head;</span><br><span class="line">    <span class="keyword">public</span> Node <span class="title function_">treeToDoublyList</span><span class="params">(Node root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        dfs(root);</span><br><span class="line">        head.left = pre;</span><br><span class="line">        pre.right = head;</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(Node cur)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (cur == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(cur.left);</span><br><span class="line">        <span class="keyword">if</span> (pre != <span class="literal">null</span>) pre.right = cur;</span><br><span class="line">        <span class="keyword">else</span> head = cur;	<span class="comment">//尾节点指向头节点</span></span><br><span class="line">        cur.left = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        dfs(cur.right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="54-二叉搜索树的第k大节点"><a href="#54-二叉搜索树的第k大节点" class="headerlink" title="54.二叉搜索树的第k大节点"></a>54.二叉搜索树的第k大节点</h2><p><img src="/SwordOffer/54.png" alt="image-20220401153927291"></p>
<blockquote>
<p>思路：转化为求“此树的中序遍历倒序的第k个节点”</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> res, k;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">kthLargest</span><span class="params">(TreeNode root, <span class="type">int</span> k)</span> &#123;</span><br><span class="line">		<span class="built_in">this</span>.k = k;</span><br><span class="line">        dfs(root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span>;</span><br><span class="line">        dfs(root.right);</span><br><span class="line">        <span class="keyword">if</span> (k == <span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (--k==<span class="number">0</span>) res = root.val;</span><br><span class="line">        dfs(root.left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="45-把数组排成最小的数"><a href="#45-把数组排成最小的数" class="headerlink" title="45.把数组排成最小的数"></a>45.把数组排成最小的数</h2><p><img src="/SwordOffer/45.png" alt="image-20220402124955223"></p>
<blockquote>
<p>思路：求拼接起来的最小数字，本质上是一个排序问题。设数组<code>nums</code>中任意两数字的字符串为<code>x</code>和<code>y</code>,则规定排序判断规则为</p>
<ul>
<li>若拼接字符串<code>x+y&gt;y+x</code>，则<code>x&gt;y</code></li>
<li>反之，则<code>x&lt;y</code></li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">minNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">		String[] strs = <span class="keyword">new</span> <span class="title class_">String</span>[nums.length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.length; i++)</span><br><span class="line">            strs[i] = String.valueOf(nums[i]);</span><br><span class="line">        Arrays.sort(strs, (x, y)-&gt;(x+y).compareTo(y+x));</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>();</span><br><span class="line">        <span class="keyword">for</span> (String s:strs)</span><br><span class="line">            res.append(s);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="61-扑克牌中的顺子"><a href="#61-扑克牌中的顺子" class="headerlink" title="61.扑克牌中的顺子"></a>61.扑克牌中的顺子</h2><p><img src="/SwordOffer/61.png" alt="image-20220402131055952"></p>
<blockquote>
<p>思路：</p>
<p>需满足如下条件</p>
<ol>
<li>除大小王外，所有牌无重复</li>
<li>设此5张牌中最大的牌为max，最小的牌为min。需满足<code>max-mix&lt;5</code></li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isStraight</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">joker</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        Arrays.sort(nums); <span class="comment">// 数组排序</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; <span class="number">4</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[i] == <span class="number">0</span>) joker++; <span class="comment">// 统计大小王数量</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] == nums[i + <span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 若有重复，提前返回 false</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">4</span>] - nums[joker] &lt; <span class="number">5</span>; <span class="comment">// 最大牌 - 最小牌 &lt; 5 则可构成顺子</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="40-最小的k个数"><a href="#40-最小的k个数" class="headerlink" title="40.最小的k个数"></a>40.最小的k个数</h2><p><img src="/SwordOffer/40.png" alt="image-20220403165040979"></p>
<blockquote>
<p>思路:快速排序</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] getLeastNumbers(<span class="type">int</span>[] arr, <span class="type">int</span> k) &#123;</span><br><span class="line">		<span class="keyword">if</span> (k == <span class="number">0</span> || arr.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 最后一个参数表示我们要找的是下标为k-1的数</span></span><br><span class="line">        <span class="keyword">return</span> quickSearch(arr, <span class="number">0</span>, arr.length - <span class="number">1</span>, k - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span>[] quickSearch(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="comment">// 每快排切分1次，找到排序后下标为j的元素，如果j恰好等于k就返回j以及j左边所有的数；</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> partition(nums, lo, hi);</span><br><span class="line">        <span class="keyword">if</span> (j == k) &#123;</span><br><span class="line">            <span class="keyword">return</span> Arrays.copyOf(nums, j + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 否则根据下标j与k的大小关系来决定继续切分左段还是右段。</span></span><br><span class="line">        <span class="keyword">return</span> j &gt; k? quickSearch(nums, lo, j - <span class="number">1</span>, k): quickSearch(nums, j + <span class="number">1</span>, hi, k);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 快排切分，返回下标j，使得比nums[j]小的数都在j的左边，比nums[j]大的数都在j的右边。</span></span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">partition</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> lo, <span class="type">int</span> hi)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">v</span> <span class="operator">=</span> nums[lo];</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> lo, j = hi + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (++i &lt;= hi &amp;&amp; nums[i] &lt; v);</span><br><span class="line">            <span class="keyword">while</span> (--j &gt;= lo &amp;&amp; nums[j] &gt; v);</span><br><span class="line">            <span class="keyword">if</span> (i &gt;= j) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="type">int</span> <span class="variable">t</span> <span class="operator">=</span> nums[j];</span><br><span class="line">            nums[j] = nums[i];</span><br><span class="line">            nums[i] = t;</span><br><span class="line">        &#125;</span><br><span class="line">        nums[lo] = nums[j];</span><br><span class="line">        nums[j] = v;</span><br><span class="line">        <span class="keyword">return</span> j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="41-数据流中的中位数"><a href="#41-数据流中的中位数" class="headerlink" title="41.数据流中的中位数"></a>41.数据流中的中位数</h2><p><img src="/SwordOffer/41.png" alt="image-20220414173712576"></p>
<blockquote>
<p>思路:建立一个 小顶堆 A 和 大顶堆 B，各保存列表的一半元素</p>
<p>设元素总数为 N &#x3D; m + n，其中 m和 n分别为 A和 B中的元素个数</p>
<ol>
<li>当m&#x3D;n时，需向A添加一个元素。实现方法：将新元素 num插入至 B，再将 B堆顶元素插入至 A</li>
<li>当m!&#x3D;n时，需向 B添加一个元素。实现方法：将新元素num插入至 A，再将 A堆顶元素插入至 B</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MedianFinder</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">    Queue&lt;Integer&gt; A, B;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MedianFinder</span><span class="params">()</span> &#123;</span><br><span class="line">        A = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;(); <span class="comment">// 小顶堆，保存较大的一半</span></span><br><span class="line">        B = <span class="keyword">new</span> <span class="title class_">PriorityQueue</span>&lt;&gt;((x, y) -&gt; (y - x)); <span class="comment">// 大顶堆，保存较小的一半</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">addNum</span><span class="params">(<span class="type">int</span> num)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(A.size() != B.size()) &#123;</span><br><span class="line">            A.add(num);</span><br><span class="line">            B.add(A.poll());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            B.add(num);</span><br><span class="line">            A.add(B.poll());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">findMedian</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> A.size() != B.size() ? A.peek() : (A.peek() + B.peek()) / <span class="number">2.0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="55-1-二叉树的深度"><a href="#55-1-二叉树的深度" class="headerlink" title="55_1.二叉树的深度"></a>55_1.二叉树的深度</h2><p><img src="/SwordOffer/55_1.png" alt="image-20220404130847134"></p>
<blockquote>
<p>思路：后序遍历</p>
<p>递归实现</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">maxDepth</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.max(maxDepth(root.left), maxDepth(root.right)) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="55-2-平衡二叉树"><a href="#55-2-平衡二叉树" class="headerlink" title="55_2.平衡二叉树"></a>55_2.平衡二叉树</h2><p><img src="/SwordOffer/55_2.png" alt="image-20220404130943563"></p>
<blockquote>
<p>思路：后序遍历+剪枝</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isBalanced</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> recur(root) != -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">recur</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">left</span> <span class="operator">=</span> recur(root.left);</span><br><span class="line">        <span class="keyword">if</span>(left == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">right</span> <span class="operator">=</span> recur(root.right);</span><br><span class="line">        <span class="keyword">if</span>(right == -<span class="number">1</span>) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> Math.abs(left - right) &lt; <span class="number">2</span> ? Math.max(left, right) + <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="64-求1-2-…-n"><a href="#64-求1-2-…-n" class="headerlink" title="64.求1+2+…+n"></a>64.求1+2+…+n</h2><p><img src="/SwordOffer/64.png" alt="image-20220405124223267"></p>
<blockquote>
<p>思路：利用递归，逻辑运算符的短路效应</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">sumNums</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">    	<span class="type">boolean</span> <span class="variable">x</span> <span class="operator">=</span> n&gt;<span class="number">1</span> &amp;&amp; sumNums(n-<span class="number">1</span>)&gt;<span class="number">0</span>;</span><br><span class="line">        res += n;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="68-1-二叉搜索树的最近公共祖先"><a href="#68-1-二叉搜索树的最近公共祖先" class="headerlink" title="68_1.二叉搜索树的最近公共祖先"></a>68_1.二叉搜索树的最近公共祖先</h2><p><img src="/SwordOffer/68_1.png" alt="image-20220406131045411"></p>
<blockquote>
<p>思路:迭代</p>
<ol>
<li>循环搜索：当节点root为空时跳出<ol>
<li>当<code>p,q</code>都在<code>root</code>的右子树中，则遍历至<code>root.right</code></li>
<li>当<em>p</em>,<em>q</em> 都在 root的左子树中，则遍历至 <code>root.left</code></li>
<li>否则，说明找到了最近公共祖先，跳出</li>
</ol>
</li>
<li>返回值：最近公共祖先<code>root</code></li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(root.val &lt; p.val &amp;&amp; root.val &lt; q.val) <span class="comment">// p,q 都在 root 的右子树中</span></span><br><span class="line">                root = root.right; <span class="comment">// 遍历至右子节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(root.val &gt; p.val &amp;&amp; root.val &gt; q.val) <span class="comment">// p,q 都在 root 的左子树中</span></span><br><span class="line">                root = root.left; <span class="comment">// 遍历至左子节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="68-2-二叉树的最近公共祖先"><a href="#68-2-二叉树的最近公共祖先" class="headerlink" title="68_2.二叉树的最近公共祖先"></a>68_2.二叉树的最近公共祖先</h2><p><img src="/SwordOffer/68_2.png" alt="image-20220406132058952"></p>
<blockquote>
<p>思路：考虑通过递归对二叉树进行&#x3D;&#x3D;先序遍历&#x3D;&#x3D;，当遇到节点<code>p</code>或<code>q</code>时返回。从底至顶回溯，当节点<code>p,q</code>在节点<code>root</code>的异侧时，节点<code>root</code>即为最近公共祖先，则向上返回<code>root</code></p>
<ol>
<li>终止条件<ol>
<li>当越过叶节点，则直接返回<code>null</code></li>
<li>当<code>root</code>等于<code>p,q</code>，则直接返回<code>root</code></li>
</ol>
</li>
<li>递推工作<ol>
<li>开启递归左子节点，返回值记为<code>left</code></li>
<li>开启递归右子节点，返回值记为<code>right</code></li>
</ol>
</li>
<li>返回值：根据<code>left,right</code>，可展开为四种情况<ol>
<li>当<code>left</code>和<code>right</code>同时为空：说明<code>root</code>的左右子树中都不包含<code>p,q</code>，返回<code>null</code></li>
<li>当<code>left</code>和<code>right</code>同时不为空，说明<code>p,q</code>分别列在<code>root</code>的异侧，因此<code>root</code>为最近公共祖先，返回<code>root</code></li>
<li>当left为空 ，right 不为空 ：p,q都不在 root的左子树中，直接返回 right。具体可分为两种情况：<ol>
<li><em>p</em>,<em>q</em> 其中一个在 root的右子树中，此时right指向 p（假设为 p）；</li>
<li><em>p</em>,<em>q</em> 两节点都在 root的右子树中，此时的 right指向最近公共祖先节点</li>
</ol>
</li>
<li>当left不为空 ，right为空：与情况3同理</li>
</ol>
</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">lowestCommonAncestor</span><span class="params">(TreeNode root, TreeNode p, TreeNode q)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span> || root == p || root == q) <span class="keyword">return</span> root;</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">left</span> <span class="operator">=</span> lowestCommonAncestor(root.left, p, q);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">right</span> <span class="operator">=</span> lowestCommonAncestor(root.right, p, q);</span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span> &amp;&amp; right == <span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">// 1.</span></span><br><span class="line">        <span class="keyword">if</span>(left == <span class="literal">null</span>) <span class="keyword">return</span> right; <span class="comment">// 3.</span></span><br><span class="line">        <span class="keyword">if</span>(right == <span class="literal">null</span>) <span class="keyword">return</span> left; <span class="comment">// 4.</span></span><br><span class="line">        <span class="keyword">return</span> root; <span class="comment">// 2. if(left != null and right != null)</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="7-重建二叉树"><a href="#7-重建二叉树" class="headerlink" title="7.重建二叉树"></a>7.重建二叉树</h2><p><img src="/SwordOffer/7.png" alt="image-20220407131448929"></p>
<blockquote>
<p>思路：</p>
<ol>
<li>前序遍历的首元素为树的根节点<code>node</code>的值</li>
<li>在中序遍历中搜索根节点<code>node</code>的索引，可将中序遍历划分为<strong>左子树|根节点|右子树</strong></li>
<li>根据中序遍历中的左右子树的节点数量，可将前序遍历划分为<strong>根节点|左子树|右子树</strong></li>
</ol>
<p>通过以上三步，可确定三个节点：1.树的根节点；2.左子树根节点；3.右子树根节点</p>
<p>根据分治算法思想，对于树的左、右子树，仍可复用以上方法划分子树的左右子树</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] preorder;</span><br><span class="line">    HashMap&lt;Integer, Integer&gt; dic = <span class="keyword">new</span> <span class="title class_">HashMap</span>&lt;&gt;();</span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">buildTree</span><span class="params">(<span class="type">int</span>[] preorder, <span class="type">int</span>[] inorder)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.preorder = preorder;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">0</span>; i &lt; inorder.length; i++)</span><br><span class="line">            dic.put(inorder[i], i);</span><br><span class="line">        <span class="keyword">return</span> recur(<span class="number">0</span>, <span class="number">0</span>, inorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    TreeNode <span class="title function_">recur</span><span class="params">(<span class="type">int</span> root, <span class="type">int</span> left, <span class="type">int</span> right)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(left &gt; right) <span class="keyword">return</span> <span class="literal">null</span>;                          <span class="comment">// 递归终止</span></span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(preorder[root]);          <span class="comment">// 建立根节点</span></span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> dic.get(preorder[root]);			<span class="comment">// 划分根节点、左子树、右子树</span></span><br><span class="line">        node.left = recur(root + <span class="number">1</span>, left, i - <span class="number">1</span>);              <span class="comment">// 开启左子树递归</span></span><br><span class="line">        node.right = recur(root + i - left + <span class="number">1</span>, i + <span class="number">1</span>, right); <span class="comment">// 开启右子树递归</span></span><br><span class="line">        <span class="keyword">return</span> node;									    <span class="comment">// 回溯返回根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="16-数值的整数次方"><a href="#16-数值的整数次方" class="headerlink" title="16.数值的整数次方"></a>16.数值的整数次方</h2><p><img src="/SwordOffer/16.png" alt="image-20220408131353688"></p>
<blockquote>
<p>思路：快速幂</p>
<p>二分法角度</p>
<ol>
<li>当x&#x3D;0时直接返回0</li>
<li>初始化res&#x3D;1</li>
<li>当n&lt;0时，把问题转化至n&gt;&#x3D;0的范围内</li>
<li>循环计算：当n&#x3D;0时跳出<ol>
<li>当n&amp;1&#x3D;1时，当前x乘入res</li>
<li>执行x&#x3D;x^2</li>
<li>执行n右移一位</li>
</ol>
</li>
<li>返回res</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span> <span class="title function_">myPow</span><span class="params">(<span class="type">double</span> x, <span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(x == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">long</span> <span class="variable">b</span> <span class="operator">=</span> n;</span><br><span class="line">        <span class="type">double</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1.0</span>;</span><br><span class="line">        <span class="keyword">if</span>(b &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x = <span class="number">1</span> / x;</span><br><span class="line">            b = -b;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(b &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>((b &amp; <span class="number">1</span>) == <span class="number">1</span>) res *= x;</span><br><span class="line">            x *= x;</span><br><span class="line">            b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="33-二叉搜索树的后序遍历序列"><a href="#33-二叉搜索树的后序遍历序列" class="headerlink" title="33.二叉搜索树的后序遍历序列"></a>33.二叉搜索树的后序遍历序列</h2><p><img src="/SwordOffer/33.png" alt="image-20220408130004388"></p>
<blockquote>
<p>思路：递归分治</p>
<p>根据二叉搜索树的定义，可以通过递归，判断所有子树的正确性，若所有子树都正确，则此序列为二叉搜索树的后序遍历</p>
<ul>
<li>终止条件：当i&gt;&#x3D;j，说明此子树节点数量&lt;&#x3D;1,无需判别正确性，直接返回true</li>
<li>递推工作<ol>
<li>划分左右子树：遍历后序遍历的[i,j]区间元素，寻找第一个大于根节点的节点，索引记为m。</li>
<li>判断是否为二叉搜索树<ul>
<li>左子树区间内所有节点都已经满足条件了，只需要判断右子树区间即可</li>
<li>右子树区间内所有节点应&gt;postorder[j]。实现方式为遍历</li>
</ul>
</li>
</ol>
</li>
<li>返回值：所有子树都需要正确才可判定正确<ol>
<li>p&#x3D;j，判断此树是否正确</li>
<li>recur(i,m-1):判断此树的左子树是否正确</li>
<li>recur(m, j-1):判断此树的右子树是否正确</li>
</ol>
</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">verifyPostorder</span><span class="params">(<span class="type">int</span>[] postorder)</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> recur(postorder, <span class="number">0</span>, postorder.length - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">boolean</span> <span class="title function_">recur</span><span class="params">(<span class="type">int</span>[] postorder, <span class="type">int</span> i, <span class="type">int</span> j)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (i&gt;=j) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="type">int</span> p=i;</span><br><span class="line">        <span class="keyword">while</span> (postorder[p] &lt; postorder[j]) p++;</span><br><span class="line">        <span class="type">int</span> <span class="variable">m</span> <span class="operator">=</span> p;</span><br><span class="line">        <span class="keyword">while</span> (postorder[p] &gt; postorder[j]) p++;</span><br><span class="line">        <span class="keyword">return</span> p==j &amp;&amp; recur(postorder, i, m-<span class="number">1</span>) &amp;&amp; recur(postorder, m, j-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="15-二进制中1的个数"><a href="#15-二进制中1的个数" class="headerlink" title="15. 二进制中1的个数"></a>15. 二进制中1的个数</h2><p><img src="/SwordOffer/15.png" alt="image-20220410210438876"></p>
<blockquote>
<p>思路：逐位判断</p>
<ul>
<li>若n&amp;1&#x3D;0，则n二进制最后一位为0；</li>
<li>若n&amp;1&#x3D;1，则n二进制最后一位为1</li>
</ul>
<p>根据此特点，使用循环判断</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">hammingWeight</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n != <span class="number">0</span>) &#123;</span><br><span class="line">            res += n &amp; <span class="number">1</span>;</span><br><span class="line">            n &gt;&gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="65-不用加减乘除做加法"><a href="#65-不用加减乘除做加法" class="headerlink" title="65.不用加减乘除做加法"></a>65.不用加减乘除做加法</h2><p><img src="/SwordOffer/65.png" alt="image-20220410210739120"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(b != <span class="number">0</span>) &#123; <span class="comment">// 当进位为 0 时跳出</span></span><br><span class="line">            <span class="type">int</span> <span class="variable">c</span> <span class="operator">=</span> (a &amp; b) &lt;&lt; <span class="number">1</span>;  <span class="comment">// c = 进位</span></span><br><span class="line">            a ^= b; <span class="comment">// a = 非进位和</span></span><br><span class="line">            b = c; <span class="comment">// b = 进位</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//递归</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">add</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 转换成非进位和 + 进位</span></span><br><span class="line">        <span class="keyword">return</span> add(a ^ b, (a &amp; b) &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="56-1-数组中数字出现的次数"><a href="#56-1-数组中数字出现的次数" class="headerlink" title="56_1.数组中数字出现的次数"></a>56_1.数组中数字出现的次数</h2><p><img src="/SwordOffer/56_1.png" alt="image-20220411134612917"></p>
<blockquote>
<p>思路：设两个只出现一次的数字x,y，由于x!&#x3D;y，则x和y二进制至少有一位不同，据此可以将nums拆分为分别包含x和y的两个子数组</p>
<p>易知两个子数组都满足 除一个数字之外，其他数字都出现了两次  因此，仿照以上简化问题的思路，分别对两个子数组遍历执行异或操作，即可得到两个只出现一次的数字x,y</p>
<ol>
<li>遍历nums执行异或</li>
<li>循环左移计算m (x⊕y的首位1)</li>
<li>拆分nums为两个子数组</li>
<li>分别遍历两个子数组执行异或</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] singleNumbers(<span class="type">int</span>[] nums) &#123;</span><br><span class="line">        <span class="type">int</span> x=<span class="number">0</span>, y=<span class="number">0</span>, n=<span class="number">0</span>, m=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums)	<span class="comment">//1.遍历异或</span></span><br><span class="line">            n ^= num;</span><br><span class="line">        <span class="keyword">while</span> ((n&amp;m)==<span class="number">0</span>)		<span class="comment">//2.循环左移，计算m</span></span><br><span class="line">            m&lt;&lt;=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num : nums)&#123;	<span class="comment">//3.遍历nums分组</span></span><br><span class="line">            <span class="keyword">if</span> ((num &amp; m) != <span class="number">0</span>) x^=num;</span><br><span class="line">            <span class="keyword">else</span> y^=num;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[]&#123;x, y&#125;;	<span class="comment">//返回出现一次的数字</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="56-2-数组中数字出现的次数"><a href="#56-2-数组中数字出现的次数" class="headerlink" title="56_2.数组中数字出现的次数"></a>56_2.数组中数字出现的次数</h2><p><img src="/SwordOffer/56_2.png" alt="image-20220411140142626"></p>
<blockquote>
<p>思路：出现三次的数字，各二进制位出现的次数都是3的倍数。因此，统计所有数字的各二进制位中1出现次数，并对3求余，结果则为只出现一次的数字</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">singleNumber</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">		<span class="comment">//遍历统计</span></span><br><span class="line">        <span class="type">int</span>[] counts = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">32</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> num:nums) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>; j&lt;<span class="number">32</span>; j++) &#123;</span><br><span class="line">                counts[j] += num &amp; <span class="number">1</span>;	<span class="comment">//获取二进制数字num的最右一位</span></span><br><span class="line">                num &gt;&gt;&gt;=<span class="number">1</span>;	<span class="comment">//无符号右移操作</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res=<span class="number">0</span>, m=<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++) &#123;</span><br><span class="line">            <span class="comment">//左移操作和或运算，将counts数组中各二进位的值恢复</span></span><br><span class="line">            res &lt;&lt;=<span class="number">1</span>;</span><br><span class="line">            res |= counts[<span class="number">31</span>-i]%m;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="39-数组中出现次数超过一般的数字"><a href="#39-数组中出现次数超过一般的数字" class="headerlink" title="39.数组中出现次数超过一般的数字"></a>39.数组中出现次数超过一般的数字</h2><p><img src="/SwordOffer/39.png" alt="image-20220411144607697"></p>
<blockquote>
<p>思路：哈希表统计&amp;数组排序&amp;摩尔投票法</p>
<p>摩尔投票法核心理念为票数正负抵消，为本题最佳解法</p>
<p>记数组首个元素为<code>n1</code>,众数为x，遍历并统计票数。当票数和为0时，剩余数组的众数一定不变</p>
<p>利用此特性，每轮假设发生票数和&#x3D;0都可以缩小剩余数组区间。当遍历完成时，最后一轮假设的数字即为众数。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">majorityElement</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">		<span class="type">int</span> x=<span class="number">0</span>, votes=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:nums) &#123;</span><br><span class="line">            <span class="keyword">if</span> (votes == <span class="number">0</span>) x=num;</span><br><span class="line">            votes += num == x ? <span class="number">1</span>:-<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="66-构建乘积数组"><a href="#66-构建乘积数组" class="headerlink" title="66.构建乘积数组"></a>66.构建乘积数组</h2><p><img src="/SwordOffer/66.png" alt="image-20220411150235894"></p>
<blockquote>
<p>思路：根据主对角线（全为1）可将表格分为上三角和下三角两部分。分别迭代计算下三角和上三角两部分的乘积</p>
<ol>
<li>初始化：数组B，其中B[0]&#x3D;1，辅助变量tmp&#x3D;1</li>
<li>计算B[i]的下三角各元素的乘积，直接乘入B[i]</li>
<li>计算B[i]的上三角各元素的乘积，记为tmp，并乘入B[i]</li>
<li>返回B</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] constructArr(<span class="type">int</span>[] a) &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">len</span> <span class="operator">=</span> a.length;</span><br><span class="line">        <span class="keyword">if</span> (len == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span>[] b = <span class="keyword">new</span> <span class="title class_">int</span>[len];</span><br><span class="line">        b[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> tmp=<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; i&lt;len; i++)&#123;</span><br><span class="line">            b[i] = b[i-<span class="number">1</span>]*a[i-<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=len-<span class="number">2</span>; i&gt;=<span class="number">0</span>; i--)&#123;</span><br><span class="line">            tmp *= a[i+<span class="number">1</span>];</span><br><span class="line">            b[i] *= tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> b;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14-1-剪绳子"><a href="#14-1-剪绳子" class="headerlink" title="14_1.剪绳子"></a>14_1.剪绳子</h2><p><img src="/SwordOffer/14_1.png" alt="image-20220412150426135"></p>
<blockquote>
<p>思路：</p>
<ol>
<li>当所有绳长度相等时，乘积最大</li>
<li>最优的绳段长度为3</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (n&lt;=<span class="number">3</span>) <span class="keyword">return</span> n-<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> a=n/<span class="number">3</span>, b=n%<span class="number">3</span>;</span><br><span class="line">        <span class="keyword">if</span> (b==<span class="number">0</span>) <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">3</span>, a);</span><br><span class="line">        <span class="keyword">if</span> (b==<span class="number">1</span>) <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">3</span>, a-<span class="number">1</span>)*<span class="number">4</span>;	<span class="comment">//将1+3转换成2+2</span></span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>)Math.pow(<span class="number">3</span>, a)*<span class="number">2</span>;		<span class="comment">//返回3^a * 2</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="57-2-和为s的连续正数序列"><a href="#57-2-和为s的连续正数序列" class="headerlink" title="57_2.和为s的连续正数序列"></a>57_2.和为s的连续正数序列</h2><p><img src="/SwordOffer/57_2.png" alt="image-20220412151212168"></p>
<blockquote>
<p>思路：滑动窗口</p>
<ol>
<li>初始化：左边界i&#x3D;1,右边界j&#x3D;2,元素和s&#x3D;3,结果列表res;</li>
<li>循环：当i&gt;&#x3D;j时跳出<ul>
<li>当s&gt;target时，向右移动左边界，更新元素和</li>
<li>当s&lt;target时，向右移动右边界，更新元素和</li>
<li>当s&#x3D;target时，记录连续整数序列，并向右移动左边界</li>
</ul>
</li>
<li>返回res</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[][] findContinuousSequence(<span class="type">int</span> target) &#123;</span><br><span class="line">		<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, j = <span class="number">2</span>, s = <span class="number">3</span>;</span><br><span class="line">        List&lt;<span class="type">int</span>[]&gt; res = <span class="keyword">new</span> <span class="title class_">ArrayList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">while</span>(i&lt;j)&#123;</span><br><span class="line">            <span class="keyword">if</span> (s==target) &#123;</span><br><span class="line">                <span class="type">int</span>[] ans = <span class="keyword">new</span> <span class="title class_">int</span>[j-i+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=i; k&lt;=j; k++)</span><br><span class="line">                    ans[k-i] = k;</span><br><span class="line">                res.add(ans);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (s&gt;=target) &#123;</span><br><span class="line">                s -= i;</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                j++;</span><br><span class="line">                s += j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>][]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="62-圆圈中最后剩下的数字"><a href="#62-圆圈中最后剩下的数字" class="headerlink" title="62.圆圈中最后剩下的数字"></a>62.圆圈中最后剩下的数字</h2><p><img src="/SwordOffer/62.png" alt="image-20220412152204133"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">lastRemaining</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">ans</span> <span class="operator">=</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">// 最后一轮剩下2个人，所以从2开始反推</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">2</span>; i &lt;= n; i++) &#123;</span><br><span class="line">            ans = (ans + m) % i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="29-顺时针打印矩阵"><a href="#29-顺时针打印矩阵" class="headerlink" title="29.顺时针打印矩阵"></a>29.顺时针打印矩阵</h2><p><img src="/SwordOffer/29.png" alt="image-20220413131355027"></p>
<blockquote>
<p>思路：模拟</p>
<ol>
<li>空值处理</li>
<li>初始化：四个边界，结果列表res</li>
<li>循环打印<ol>
<li>根据边界打印，即将元素按顺序添加至列表res尾部</li>
<li>边界向内收缩1</li>
<li>判断是否打印完毕，若打印完毕则跳出</li>
</ol>
</li>
<li>返回值：res</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] spiralOrder(<span class="type">int</span>[][] matrix) &#123;</span><br><span class="line">        <span class="keyword">if</span>(matrix.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> <span class="variable">l</span> <span class="operator">=</span> <span class="number">0</span>, r = matrix[<span class="number">0</span>].length - <span class="number">1</span>, t = <span class="number">0</span>, b = matrix.length - <span class="number">1</span>, x = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[(r + <span class="number">1</span>) * (b + <span class="number">1</span>)];</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> l; i &lt;= r; i++) res[x++] = matrix[t][i]; <span class="comment">// left to right.</span></span><br><span class="line">            <span class="keyword">if</span>(++t &gt; b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> t; i &lt;= b; i++) res[x++] = matrix[i][r]; <span class="comment">// top to bottom.</span></span><br><span class="line">            <span class="keyword">if</span>(l &gt; --r) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> r; i &gt;= l; i--) res[x++] = matrix[b][i]; <span class="comment">// right to left.</span></span><br><span class="line">            <span class="keyword">if</span>(t &gt; --b) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> b; i &gt;= t; i--) res[x++] = matrix[i][l]; <span class="comment">// bottom to top.</span></span><br><span class="line">            <span class="keyword">if</span>(++l &gt; r) <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="31-栈的压入、弹出序列"><a href="#31-栈的压入、弹出序列" class="headerlink" title="31.栈的压入、弹出序列"></a>31.栈的压入、弹出序列</h2><p><img src="/SwordOffer/31.png" alt="image-20220413131552983"></p>
<blockquote>
<p>思路：模拟</p>
<ol>
<li>初始化：辅助栈stack,弹出序列的索引<code>i</code></li>
<li>遍历压栈序列：各元素记为num<ol>
<li>元素num入栈</li>
<li>循环出栈：若stack的栈顶元素&#x3D;弹出序列元素<code>popped[i]</code>，则执行出栈与<code>i++</code></li>
</ol>
</li>
<li>返回值：若stack为空，则此弹出序列合法</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">validateStackSequences</span><span class="params">(<span class="type">int</span>[] pushed, <span class="type">int</span>[] popped)</span> &#123;</span><br><span class="line">		Stack&lt;Integer&gt; stack = <span class="keyword">new</span> <span class="title class_">Stack</span>&lt;&gt;();</span><br><span class="line">        <span class="type">int</span> i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> num:pushed) &#123;</span><br><span class="line">            stack.push(num);</span><br><span class="line">            <span class="keyword">while</span>(!stack.isEmpty() &amp;&amp; stack.peek()==popped[i]) &#123;</span><br><span class="line">                <span class="comment">//循环判断与出栈</span></span><br><span class="line">                stack.pop();</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> stack.isEmpty();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="20-表示数值的字符串"><a href="#20-表示数值的字符串" class="headerlink" title="20.表示数值的字符串"></a>20.表示数值的字符串</h2><p><img src="/SwordOffer/20.png" alt="image-20220413131714196"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isNumber</span><span class="params">(String s)</span> &#123;</span><br><span class="line">        <span class="comment">// s为空对象或 s长度为0(空字符串)时, 不能表示数值</span></span><br><span class="line">        <span class="keyword">if</span>(s == <span class="literal">null</span> || s.length() == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">        <span class="comment">// 标记是否遇到数位、小数点、‘e’或&#x27;E&#x27;</span></span><br><span class="line">        <span class="type">boolean</span> <span class="variable">isNum</span> <span class="operator">=</span> <span class="literal">false</span>, isDot = <span class="literal">false</span>, ise_or_E = <span class="literal">false</span>; </span><br><span class="line">        <span class="comment">// 删除字符串头尾的空格，转为字符数组，方便遍历判断每个字符</span></span><br><span class="line">        <span class="type">char</span>[] str = s.trim().toCharArray();  </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;str.length; i++) &#123;</span><br><span class="line">            <span class="comment">// 判断当前字符是否为 0~9 的数位</span></span><br><span class="line">            <span class="keyword">if</span>(str[i] &gt;= <span class="string">&#x27;0&#x27;</span> &amp;&amp; str[i] &lt;= <span class="string">&#x27;9&#x27;</span>) isNum = <span class="literal">true</span>; </span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;.&#x27;</span>) &#123; <span class="comment">// 遇到小数点</span></span><br><span class="line">                <span class="comment">// 小数点之前可以没有整数，但是不能重复出现小数点、或出现‘e’、&#x27;E&#x27;</span></span><br><span class="line">                <span class="keyword">if</span>(isDot || ise_or_E) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">                isDot = <span class="literal">true</span>; <span class="comment">// 标记已经遇到小数点</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;e&#x27;</span> || str[i] == <span class="string">&#x27;E&#x27;</span>) &#123; <span class="comment">// 遇到‘e’或&#x27;E&#x27;</span></span><br><span class="line">                <span class="comment">// ‘e’或&#x27;E&#x27;前面必须有整数，且前面不能重复出现‘e’或&#x27;E&#x27;</span></span><br><span class="line">                <span class="keyword">if</span>(!isNum || ise_or_E) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">                ise_or_E = <span class="literal">true</span>; <span class="comment">// 标记已经遇到‘e’或&#x27;E&#x27;</span></span><br><span class="line">            <span class="comment">// 重置isNum，因为‘e’或&#x27;E&#x27;之后也必须接上整数，防止出现 123e或者123e+的非法情况</span></span><br><span class="line">                isNum = <span class="literal">false</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(str[i] == <span class="string">&#x27;-&#x27;</span> ||str[i] == <span class="string">&#x27;+&#x27;</span>) &#123; </span><br><span class="line">                <span class="comment">// 正负号只可能出现在第一个位置，或者出现在‘e’或&#x27;E&#x27;的后面一个位置</span></span><br><span class="line">                <span class="keyword">if</span>(i!=<span class="number">0</span> &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">&#x27;e&#x27;</span> &amp;&amp; str[i-<span class="number">1</span>] != <span class="string">&#x27;E&#x27;</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">return</span> <span class="literal">false</span>; <span class="comment">// 其它情况均为不合法字符</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> isNum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="67-把字符串转换成整数"><a href="#67-把字符串转换成整数" class="headerlink" title="67.把字符串转换成整数"></a>67.把字符串转换成整数</h2><p><img src="/SwordOffer/67.png" alt="image-20220413131801360"></p>
<blockquote>
<p>思路：</p>
<ol>
<li>首部空格：删除即可</li>
<li>符号位：三种情况，新建一个变量保存符号位，返回前判断正负即可</li>
<li>非数字字符：遇到首个非数字的字符时，应立即返回</li>
<li>数字字符<ol>
<li>字符转数字：数字的ASCII码与0的ASCII码相减即可</li>
<li>数字拼接</li>
</ol>
</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">strToInt</span><span class="params">(String str)</span> &#123;</span><br><span class="line">        <span class="type">char</span>[] c = str.trim().toCharArray();</span><br><span class="line">        <span class="keyword">if</span>(c.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">0</span>, bndry = Integer.MAX_VALUE / <span class="number">10</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>, sign = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(c[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) sign = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(c[<span class="number">0</span>] != <span class="string">&#x27;+&#x27;</span>) i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> <span class="variable">j</span> <span class="operator">=</span> i; j &lt; c.length; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(c[j] &lt; <span class="string">&#x27;0&#x27;</span> || c[j] &gt; <span class="string">&#x27;9&#x27;</span>) <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">if</span>(res &gt; bndry || res == bndry &amp;&amp; c[j] &gt; <span class="string">&#x27;7&#x27;</span>) <span class="type">return</span> <span class="variable">sign</span> <span class="operator">=</span>= <span class="number">1</span> ? Integer.MAX_VALUE : Integer.MIN_VALUE;</span><br><span class="line">            res = res * <span class="number">10</span> + (c[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sign * res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="59-1-滑动窗口的最大值"><a href="#59-1-滑动窗口的最大值" class="headerlink" title="59_1.滑动窗口的最大值"></a>59_1.滑动窗口的最大值</h2><p><img src="/SwordOffer/59_1.png" alt="image-20220413131910097"></p>
<blockquote>
<p>思路：单调队列</p>
<ol>
<li>初始化：双端队列deque，结果列表res</li>
<li>滑动窗口：左边界范围i∈[1-k, n-k],右边界范围j∈[0,n-1]<ol>
<li>若i&gt;0且队首元素deque[0]&#x3D;被删元素nums[i-1];则队首元素出队</li>
<li>删除deque内所有&lt;nums[j]的元素，以保持deque递减</li>
<li>将nums[j]添加至deque尾部</li>
<li>若已形成窗口(i&gt;&#x3D;0)：将窗口最大值（即队首元素deque[0]）添加至列表res</li>
</ol>
</li>
<li>返回值：返回结果列表res</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span>[] maxSlidingWindow(<span class="type">int</span>[] nums, <span class="type">int</span> k) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.length == <span class="number">0</span> || k == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span>[] res = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length - k + <span class="number">1</span>];</span><br><span class="line">        Deque&lt;Integer&gt; deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>, i=<span class="number">1</span>-k; j&lt;nums.length; i++,j++) &#123;</span><br><span class="line">            <span class="comment">//删除deque中对应的nums[i-1]</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;<span class="number">0</span> &amp;&amp; deque.peekFirst() == nums[i-<span class="number">1</span>])</span><br><span class="line">                deque.removeFirst();</span><br><span class="line">            <span class="comment">//保持deque递减</span></span><br><span class="line">            <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; nums[j])</span><br><span class="line">                deque.removeLast();</span><br><span class="line">            deque.addLast(nums[j]);</span><br><span class="line">            <span class="comment">//记录窗口最大值</span></span><br><span class="line">            <span class="keyword">if</span>(i&gt;=<span class="number">0</span>)</span><br><span class="line">                res[i] = deque.peekFirst();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="59-2-队列的最大值"><a href="#59-2-队列的最大值" class="headerlink" title="59_2.队列的最大值"></a>59_2.队列的最大值</h2><p><img src="/SwordOffer/59_2.png" alt="image-20220413132058393"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MaxQueue</span> &#123;</span><br><span class="line">    Queue&lt;Integer&gt; queue;</span><br><span class="line">    Deque&lt;Integer&gt; deque;</span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">MaxQueue</span><span class="params">()</span> &#123;</span><br><span class="line">        queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">        deque = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">max_value</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> deque.isEmpty() ? -<span class="number">1</span> : deque.peekFirst();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">push_back</span><span class="params">(<span class="type">int</span> value)</span> &#123;</span><br><span class="line">        queue.offer(value);</span><br><span class="line">        <span class="keyword">while</span>(!deque.isEmpty() &amp;&amp; deque.peekLast() &lt; value)</span><br><span class="line">            deque.pollLast();</span><br><span class="line">        deque.offerLast(value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">pop_front</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(queue.isEmpty()) <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(queue.peek().equals(deque.peekFirst()))</span><br><span class="line">            deque.pollFirst();</span><br><span class="line">        <span class="keyword">return</span> queue.poll();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MaxQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MaxQueue obj = new MaxQueue();</span></span><br><span class="line"><span class="comment"> * int param_1 = obj.max_value();</span></span><br><span class="line"><span class="comment"> * obj.push_back(value);</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.pop_front();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>

<h2 id="37-序列化二叉树"><a href="#37-序列化二叉树" class="headerlink" title="37.序列化二叉树"></a>37.序列化二叉树</h2><p><img src="/SwordOffer/37.png" alt="image-20220414163345860"></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Codec</span> &#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Encodes a tree to a single string.</span></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">serialize</span><span class="params">(TreeNode root)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">null</span>) <span class="keyword">return</span> <span class="string">&quot;[]&quot;</span>;</span><br><span class="line">        <span class="type">StringBuilder</span> <span class="variable">res</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">StringBuilder</span>(<span class="string">&quot;[&quot;</span>);</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;() &#123;&#123; add(root); &#125;&#125;;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(node != <span class="literal">null</span>) &#123;</span><br><span class="line">                res.append(node.val + <span class="string">&quot;,&quot;</span>);</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> res.append(<span class="string">&quot;null,&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        res.deleteCharAt(res.length() - <span class="number">1</span>);</span><br><span class="line">        res.append(<span class="string">&quot;]&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> res.toString();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Decodes your encoded data to tree.</span></span><br><span class="line">    <span class="keyword">public</span> TreeNode <span class="title function_">deserialize</span><span class="params">(String data)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(data.equals(<span class="string">&quot;[]&quot;</span>)) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">        String[] vals = data.substring(<span class="number">1</span>, data.length() - <span class="number">1</span>).split(<span class="string">&quot;,&quot;</span>);</span><br><span class="line">        <span class="type">TreeNode</span> <span class="variable">root</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(vals[<span class="number">0</span>]));</span><br><span class="line">        Queue&lt;TreeNode&gt; queue = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;() &#123;&#123; add(root); &#125;&#125;;</span><br><span class="line">        <span class="type">int</span> <span class="variable">i</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!queue.isEmpty()) &#123;</span><br><span class="line">            <span class="type">TreeNode</span> <span class="variable">node</span> <span class="operator">=</span> queue.poll();</span><br><span class="line">            <span class="keyword">if</span>(!vals[i].equals(<span class="string">&quot;null&quot;</span>)) &#123;</span><br><span class="line">                node.left = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(vals[i]));</span><br><span class="line">                queue.add(node.left);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span>(!vals[i].equals(<span class="string">&quot;null&quot;</span>)) &#123;</span><br><span class="line">                node.right = <span class="keyword">new</span> <span class="title class_">TreeNode</span>(Integer.parseInt(vals[i]));</span><br><span class="line">                queue.add(node.right);</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Your Codec object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment">// Codec codec = new Codec();</span></span><br><span class="line"><span class="comment">// codec.deserialize(codec.serialize(root));</span></span><br></pre></td></tr></table></figure>

<h2 id="38-字符串的排列"><a href="#38-字符串的排列" class="headerlink" title="38.字符串的排列"></a>38.字符串的排列</h2><p><img src="/SwordOffer/38.png" alt="image-20220414163440986"></p>
<blockquote>
<p>思路：回溯法</p>
<ol>
<li>终止条件：当x&#x3D;len(c)-1时，代表所有位已固定，则将当前组合c转化为字符串并加入res，并返回</li>
<li>递推参数：当前固定位x</li>
<li>递推工作：初始化一个Set，用于排除重复的字符；将第x位字符与i∈[x,len(c)]字符分别交换，并进入下一层递归<ol>
<li>剪枝：若c[i]在set中，代表其实重复字符，因此剪枝</li>
<li>将c[i]加入Set，以便之后遇到重复字符时剪枝</li>
<li>固定字符：将字符c[i]和c[x]交换，即固定c[i]为当前位字符</li>
<li>开启下层递归：调用dfs(x+1)，即开始固定第x+1个字符</li>
<li>还原交换：将字符c[i]与c[x]交换（还原之前的交换）</li>
</ol>
</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    List&lt;String&gt; res = <span class="keyword">new</span> <span class="title class_">LinkedList</span>&lt;&gt;();</span><br><span class="line">    <span class="type">char</span>[] c;</span><br><span class="line">    <span class="keyword">public</span> String[] permutation(String s) &#123;</span><br><span class="line">		c = s.toCharArray();</span><br><span class="line">        dfs(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> res.toArray(<span class="keyword">new</span> <span class="title class_">String</span>[res.size()]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">dfs</span><span class="params">(<span class="type">int</span> x)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (x == c.length-<span class="number">1</span>) &#123;</span><br><span class="line">            res.add(String.valueOf(c));	<span class="comment">//添加排列方案</span></span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        HashSet&lt;Character&gt; set = <span class="keyword">new</span> <span class="title class_">HashSet</span>&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=x; i&lt;c.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(set.contains(c[i])) <span class="keyword">continue</span>;	<span class="comment">//重复 因此剪枝</span></span><br><span class="line">            set.add(c[i]);</span><br><span class="line">            swap(i,x);	<span class="comment">//交换 将c[i]固定在第x位</span></span><br><span class="line">            dfs(x+<span class="number">1</span>);	<span class="comment">//开启固定第x+1位字符</span></span><br><span class="line">            swap(i,x);	<span class="comment">//恢复交换</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">void</span> <span class="title function_">swap</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> &#123;</span><br><span class="line">        <span class="type">char</span> <span class="variable">tmp</span> <span class="operator">=</span> c[a];</span><br><span class="line">        c[a] = c[b];</span><br><span class="line">        c[b] = tmp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="19-正则表达式匹配"><a href="#19-正则表达式匹配" class="headerlink" title="19.正则表达式匹配"></a>19.正则表达式匹配</h2><p><img src="/SwordOffer/19.png" alt="image-20220414174429975"></p>
<blockquote>
<p>思路：动态规划</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isMatch</span><span class="params">(String s, String p)</span> &#123;</span><br><span class="line">		</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="49-丑数"><a href="#49-丑数" class="headerlink" title="49.丑数"></a>49.丑数</h2><p><img src="/SwordOffer/49.png" alt="image-20220414174523999"></p>
<blockquote>
<p>思路：动态规划</p>
<ul>
<li>状态定义：设动态规划列表dp，dp[i]代表第i+1个丑数</li>
<li>转移方程：<ol>
<li>当索引a,b,c满足以下条件时，dp[i]为三种情况的最小值</li>
<li>每轮计算dp[i]后，需要更新索引a,b,c的值，使其始终满足方程条件。实现方法：分别独立判断dp[i]和<code>dp[a]x2,dp[b]x3,dp[c]x5</code>的大小关系，若相等则相应索引a,b,c加1</li>
</ol>
</li>
</ul>
<p><code>dp[a]×2&gt;dp[i−1]≥dp[a−1]×2 dp[b]×3&gt;dp[i−1]≥dp[b−1]×3 dp[c]×5&gt;dp[i−1]≥dp[c−1]×5</code></p>
<p><code>dp[i] = min(dp[a]x2, dp[b]x3, dp[c]x5)</code></p>
<ul>
<li>初始状态：dp[0]&#x3D;1，即第一个丑数为1</li>
<li>返回值：dp[n-1]，即返回第n个丑数</li>
</ul>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">nthUglyNumber</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="type">int</span> a=<span class="number">0</span>,b=<span class="number">0</span>,c=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span>[] dp = <span class="keyword">new</span> <span class="title class_">int</span>[n];</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> <span class="variable">n2</span> <span class="operator">=</span> dp[a]*<span class="number">2</span>, n3 = dp[b]*<span class="number">3</span>, n5=dp[c]*<span class="number">5</span>;</span><br><span class="line">            dp[i] = Math.min(Math.min(n2,n3),n5);</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == n2) a++;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == n3) b++;</span><br><span class="line">            <span class="keyword">if</span>(dp[i] == n5) c++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n-<span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="60-n个骰子的点数"><a href="#60-n个骰子的点数" class="headerlink" title="60.n个骰子的点数"></a>60.n个骰子的点数</h2><p><img src="/SwordOffer/60.png" alt="image-20220415204852173"></p>
<blockquote>
<p>思路：动态规划</p>
<p>可通过子问题的解f(n-1)可递推计算出f(n)，而输入一个骰子的解f(1)已知，因此可通过解f(1)依次递推出任意解f(n)</p>
<p>由于新增骰子的点数只可能为1至6，因此概率f(n-1,x)仅与f(n,x+1),f(n,x+2)……f(n,x+6)相关。因而，遍历f(n-1)中各点数和的概率，并将其相加至f(n)中所有相关项，即可完成f(n-1)至f(n)的递推</p>
<p>通常做法是声明一个二维数组dp, <code>dp[i][j]</code>代表前i个骰子的点数和j的概率，并执行状态转移。而由于dp[i]仅由dp[i-1]递推得出，为降低空间复杂度，只建立两个一维数组dp和tmp交替前进即可</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">double</span>[] dicesProbability(<span class="type">int</span> n) &#123;</span><br><span class="line">        <span class="type">double</span>[] dp = <span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">6</span>];</span><br><span class="line">        Arrays.fill(dp, <span class="number">1.0</span>/<span class="number">6.0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=n; i++) &#123;</span><br><span class="line">            <span class="type">double</span>[] tmp = <span class="keyword">new</span> <span class="title class_">double</span>[<span class="number">5</span>*i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;dp.length;j++)&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k=<span class="number">0</span>; k&lt;<span class="number">6</span>; k++) &#123;</span><br><span class="line">                    tmp[j+k] += dp[j]/<span class="number">6.0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            dp = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="51-数组中的逆序对"><a href="#51-数组中的逆序对" class="headerlink" title="51.数组中的逆序对"></a>51.数组中的逆序对</h2><p><img src="/SwordOffer/51.png" alt="image-20220415214612858"></p>
<blockquote>
<p>思路：</p>
<ol>
<li>终止条件：当l&gt;&#x3D;r时，代表子数组长度为1，此时终止划分</li>
<li>递归划分：计算数组中点m,递归划分左子数组和右子数组</li>
<li>合并与逆序对统计<ol>
<li>暂存数组nums闭区间[l,r]内的元素至辅助数组tmp</li>
<li>循环合并：设置双指针i,j分别指向左右子数组的首元素<ul>
<li>当i&#x3D;m+1时：代表左子数组已合并完，因此添加右子数组当前元素tmp[j]，并执行j&#x3D;j+1</li>
<li>否则，当j&#x3D;r+1时：代表右子数组已合并完，因此添加左子数组当前元素tmp[i],并执行i&#x3D;i+1</li>
<li>否则，当tmp[i]&lt;&#x3D;tmp[j]:添加左子数组当前元素tmp[i，并执行i&#x3D;i+1</li>
<li>否则添加右子数组当前元素tmp[j]，并执行j&#x3D;j+1；此时构成m-i+1个逆序对，统计添加至res</li>
</ul>
</li>
</ol>
</li>
<li>返回值</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="type">int</span>[] nums, tmp;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">reversePairs</span><span class="params">(<span class="type">int</span>[] nums)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.nums = nums;</span><br><span class="line">        tmp = <span class="keyword">new</span> <span class="title class_">int</span>[nums.length];</span><br><span class="line">        <span class="keyword">return</span> mergeSort(<span class="number">0</span>, nums.length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">private</span> <span class="type">int</span> <span class="title function_">mergeSort</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> &#123;</span><br><span class="line">        <span class="comment">//终止条件</span></span><br><span class="line">        <span class="keyword">if</span>(l&gt;=r) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//递归划分</span></span><br><span class="line">        <span class="type">int</span> m=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="type">int</span> <span class="variable">res</span> <span class="operator">=</span> mergeSort(l,m)+mergeSort(m+<span class="number">1</span>, r);</span><br><span class="line">        <span class="comment">//合并阶段</span></span><br><span class="line">        <span class="type">int</span> i=l,j=m+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;=r;k++)</span><br><span class="line">            tmp[k] = nums[k];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k=l;k&lt;=r;k++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i==m+<span class="number">1</span>)</span><br><span class="line">                nums[k]=tmp[j++];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(j==r+<span class="number">1</span>||tmp[i]&lt;=tmp[j])</span><br><span class="line">                nums[k]=tmp[i++];</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                nums[k]=tmp[j++];</span><br><span class="line">                res+=m-i+<span class="number">1</span>;	<span class="comment">//统计逆序对</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="14-2-剪绳子"><a href="#14-2-剪绳子" class="headerlink" title="14_2.剪绳子"></a>14_2.剪绳子</h2><p><img src="/SwordOffer/14_2.png" alt="image-20220415223334179"></p>
<blockquote>
<p>思路：贪心算法</p>
<ol>
<li>如果 n &#x3D;&#x3D; 2，返回1，如果 n &#x3D;&#x3D; 3，返回2，两个可以合并成n小于4的时候返回n - 1</li>
<li>如果 n &#x3D;&#x3D; 4，返回4</li>
<li>如果 n &gt; 4，分成尽可能多的长度为3的小段，每次循环长度n减去3，乘积res乘以3；最后返回时乘以小于等于4的最后一小段；每次乘法操作后记得取余就行</li>
<li>以上2和3可以合并</li>
</ol>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> <span class="title function_">cuttingRope</span><span class="params">(<span class="type">int</span> n)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt; <span class="number">4</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> n - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">long</span> <span class="variable">res</span> <span class="operator">=</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(n &gt; <span class="number">4</span>)&#123;</span><br><span class="line">            res  = res * <span class="number">3</span> % <span class="number">1000000007</span>;</span><br><span class="line">            n -= <span class="number">3</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (<span class="type">int</span>) (res * n % <span class="number">1000000007</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E7%AE%97%E6%B3%95/" rel="tag"># 算法</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2022/04/30/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/" rel="next" title="计算机网络">
                <i class="fa fa-chevron-left"></i> 计算机网络
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/cat.jpg"
                alt="" />
            
              <p class="site-author-name" itemprop="name"></p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">17</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">10</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/zhaoxfan98" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="mailto:zhaoxfan98@gmail.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
            </div>
          

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#9-%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97"><span class="nav-number">1.</span> <span class="nav-text">9.用两个栈实现队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#30-%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E7%9A%84%E6%A0%88"><span class="nav-number">2.</span> <span class="nav-text">30.包含min函数的栈</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8"><span class="nav-number">3.</span> <span class="nav-text">6.从尾到头打印链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#24-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8"><span class="nav-number">4.</span> <span class="nav-text">24.反转链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#35-%E5%A4%8D%E6%9D%82%E9%93%BE%E8%A1%A8%E7%9A%84%E5%A4%8D%E5%88%B6"><span class="nav-number">5.</span> <span class="nav-text">35.复杂链表的复制</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-%E6%9B%BF%E6%8D%A2%E7%A9%BA%E6%A0%BC"><span class="nav-number">6.</span> <span class="nav-text">5.替换空格</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#58-%E5%B7%A6%E6%97%8B%E8%BD%AC%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">7.</span> <span class="nav-text">58.左旋转字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">8.</span> <span class="nav-text">3.数组中重复的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#53-%E5%9C%A8%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E6%9F%A5%E6%89%BE%E6%95%B0%E5%AD%97"><span class="nav-number">9.</span> <span class="nav-text">53.在排序数组中查找数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#53-0-n-1%E4%B8%AD%E7%BC%BA%E5%A4%B1%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">10.</span> <span class="nav-text">53.0~n-1中缺失的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="nav-number">11.</span> <span class="nav-text">4.二维数组中的查找</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#11-%E6%97%8B%E8%BD%AC%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%B0%8F%E6%95%B0%E5%AD%97"><span class="nav-number">12.</span> <span class="nav-text">11.旋转数组的最小数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#50-%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8F%AA%E5%87%BA%E7%8E%B0%E4%B8%80%E6%AC%A1%E7%9A%84%E5%AD%97%E7%AC%A6"><span class="nav-number">13.</span> <span class="nav-text">50.第一个只出现一次的字符</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32-1-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">14.</span> <span class="nav-text">32_1.从上到下打印二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32-2-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">15.</span> <span class="nav-text">32_2.从上到下打印二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#32-3-%E4%BB%8E%E4%B8%8A%E5%88%B0%E4%B8%8B%E6%89%93%E5%8D%B0%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">16.</span> <span class="nav-text">32_3.从上到下打印二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#26-%E6%A0%91%E7%9A%84%E5%AD%90%E7%BB%93%E6%9E%84"><span class="nav-number">17.</span> <span class="nav-text">26.树的子结构</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#27-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%95%9C%E5%83%8F"><span class="nav-number">18.</span> <span class="nav-text">27.二叉树的镜像</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#28-%E5%AF%B9%E7%A7%B0%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">19.</span> <span class="nav-text">28.对称的二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-1-%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91%E6%95%B0%E5%88%97"><span class="nav-number">20.</span> <span class="nav-text">10_1.斐波那契数列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#10-2-%E9%9D%92%E8%9B%99%E8%B7%B3%E5%8F%B0%E9%98%B6%E9%97%AE%E9%A2%98"><span class="nav-number">21.</span> <span class="nav-text">10_2.青蛙跳台阶问题</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#63-%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E5%A4%A7%E5%88%A9%E6%B6%A6"><span class="nav-number">22.</span> <span class="nav-text">63.股票的最大利润</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#42-%E8%BF%9E%E7%BB%AD%E5%AD%90%E6%95%B0%E7%BB%84%E7%9A%84%E6%9C%80%E5%A4%A7%E5%92%8C"><span class="nav-number">23.</span> <span class="nav-text">42.连续子数组的最大和</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#47-%E7%A4%BC%E7%89%A9%E7%9A%84%E6%9C%80%E5%A4%A7%E4%BB%B7%E5%80%BC"><span class="nav-number">24.</span> <span class="nav-text">47.礼物的最大价值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#46-%E6%8A%8A%E6%95%B0%E5%AD%97%E7%BF%BB%E8%AF%91%E6%88%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">25.</span> <span class="nav-text">46. 把数字翻译成字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#48-%E6%9C%80%E9%95%BF%E4%B8%8D%E5%90%AB%E9%87%8D%E5%A4%8D%E5%AD%97%E7%AC%A6%E7%9A%84%E5%AD%90%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">26.</span> <span class="nav-text">48.最长不含重复字符的子字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#18-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E8%8A%82%E7%82%B9"><span class="nav-number">27.</span> <span class="nav-text">18.删除链表的节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#22-%E9%93%BE%E8%A1%A8%E4%B8%AD%E5%80%92%E6%95%B0%E7%AC%ACk%E4%B8%AA%E8%8A%82%E7%82%B9"><span class="nav-number">28.</span> <span class="nav-text">22.链表中倒数第k个节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#25-%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%8E%92%E5%BA%8F%E7%9A%84%E9%93%BE%E8%A1%A8"><span class="nav-number">29.</span> <span class="nav-text">25.合并两个排序的链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#52-%E4%B8%A4%E4%B8%AA%E9%93%BE%E8%A1%A8%E7%9A%84%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%85%AC%E5%85%B1%E8%8A%82%E7%82%B9"><span class="nav-number">30.</span> <span class="nav-text">52.两个链表的第一个公共节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#21-%E8%B0%83%E6%95%B4%E6%95%B0%E7%BB%84%E9%A1%BA%E5%BA%8F%E4%BD%BF%E5%A5%87%E6%95%B0%E4%BD%8D%E4%BA%8E%E5%81%B6%E6%95%B0%E5%89%8D%E9%9D%A2"><span class="nav-number">31.</span> <span class="nav-text">21.调整数组顺序使奇数位于偶数前面</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#57-%E5%92%8C%E4%B8%BAs%E7%9A%84%E4%B8%A4%E4%B8%AA%E6%95%B0%E5%AD%97"><span class="nav-number">32.</span> <span class="nav-text">57.和为s的两个数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#58-1-%E7%BF%BB%E8%BD%AC%E5%8D%95%E8%AF%8D%E9%A1%BA%E5%BA%8F"><span class="nav-number">33.</span> <span class="nav-text">58_1.翻转单词顺序</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#12-%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="nav-number">34.</span> <span class="nav-text">12.矩阵中的路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#13-%E6%9C%BA%E5%99%A8%E4%BA%BA%E7%9A%84%E8%BF%90%E5%8A%A8%E8%8C%83%E5%9B%B4"><span class="nav-number">35.</span> <span class="nav-text">13.机器人的运动范围</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#34-%E4%BA%8C%E5%8F%89%E6%A0%91%E4%B8%AD%E5%92%8C%E4%B8%BA%E6%9F%90%E4%B8%80%E5%80%BC%E7%9A%84%E8%B7%AF%E5%BE%84"><span class="nav-number">36.</span> <span class="nav-text">34.二叉树中和为某一值的路径</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#36-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E4%B8%8E%E5%8F%8C%E5%90%91%E9%93%BE%E8%A1%A8"><span class="nav-number">37.</span> <span class="nav-text">36.二叉搜索树与双向链表</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#54-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E7%AC%ACk%E5%A4%A7%E8%8A%82%E7%82%B9"><span class="nav-number">38.</span> <span class="nav-text">54.二叉搜索树的第k大节点</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#45-%E6%8A%8A%E6%95%B0%E7%BB%84%E6%8E%92%E6%88%90%E6%9C%80%E5%B0%8F%E7%9A%84%E6%95%B0"><span class="nav-number">39.</span> <span class="nav-text">45.把数组排成最小的数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#61-%E6%89%91%E5%85%8B%E7%89%8C%E4%B8%AD%E7%9A%84%E9%A1%BA%E5%AD%90"><span class="nav-number">40.</span> <span class="nav-text">61.扑克牌中的顺子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#40-%E6%9C%80%E5%B0%8F%E7%9A%84k%E4%B8%AA%E6%95%B0"><span class="nav-number">41.</span> <span class="nav-text">40.最小的k个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#41-%E6%95%B0%E6%8D%AE%E6%B5%81%E4%B8%AD%E7%9A%84%E4%B8%AD%E4%BD%8D%E6%95%B0"><span class="nav-number">42.</span> <span class="nav-text">41.数据流中的中位数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#55-1-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="nav-number">43.</span> <span class="nav-text">55_1.二叉树的深度</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#55-2-%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">44.</span> <span class="nav-text">55_2.平衡二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#64-%E6%B1%821-2-%E2%80%A6-n"><span class="nav-number">45.</span> <span class="nav-text">64.求1+2+…+n</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#68-1-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">46.</span> <span class="nav-text">68_1.二叉搜索树的最近公共祖先</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#68-2-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%9C%80%E8%BF%91%E5%85%AC%E5%85%B1%E7%A5%96%E5%85%88"><span class="nav-number">47.</span> <span class="nav-text">68_2.二叉树的最近公共祖先</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-%E9%87%8D%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">48.</span> <span class="nav-text">7.重建二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#16-%E6%95%B0%E5%80%BC%E7%9A%84%E6%95%B4%E6%95%B0%E6%AC%A1%E6%96%B9"><span class="nav-number">49.</span> <span class="nav-text">16.数值的整数次方</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#33-%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%E7%9A%84%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86%E5%BA%8F%E5%88%97"><span class="nav-number">50.</span> <span class="nav-text">33.二叉搜索树的后序遍历序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#15-%E4%BA%8C%E8%BF%9B%E5%88%B6%E4%B8%AD1%E7%9A%84%E4%B8%AA%E6%95%B0"><span class="nav-number">51.</span> <span class="nav-text">15. 二进制中1的个数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#65-%E4%B8%8D%E7%94%A8%E5%8A%A0%E5%87%8F%E4%B9%98%E9%99%A4%E5%81%9A%E5%8A%A0%E6%B3%95"><span class="nav-number">52.</span> <span class="nav-text">65.不用加减乘除做加法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#56-1-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="nav-number">53.</span> <span class="nav-text">56_1.数组中数字出现的次数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#56-2-%E6%95%B0%E7%BB%84%E4%B8%AD%E6%95%B0%E5%AD%97%E5%87%BA%E7%8E%B0%E7%9A%84%E6%AC%A1%E6%95%B0"><span class="nav-number">54.</span> <span class="nav-text">56_2.数组中数字出现的次数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#39-%E6%95%B0%E7%BB%84%E4%B8%AD%E5%87%BA%E7%8E%B0%E6%AC%A1%E6%95%B0%E8%B6%85%E8%BF%87%E4%B8%80%E8%88%AC%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">55.</span> <span class="nav-text">39.数组中出现次数超过一般的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#66-%E6%9E%84%E5%BB%BA%E4%B9%98%E7%A7%AF%E6%95%B0%E7%BB%84"><span class="nav-number">56.</span> <span class="nav-text">66.构建乘积数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-1-%E5%89%AA%E7%BB%B3%E5%AD%90"><span class="nav-number">57.</span> <span class="nav-text">14_1.剪绳子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#57-2-%E5%92%8C%E4%B8%BAs%E7%9A%84%E8%BF%9E%E7%BB%AD%E6%AD%A3%E6%95%B0%E5%BA%8F%E5%88%97"><span class="nav-number">58.</span> <span class="nav-text">57_2.和为s的连续正数序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#62-%E5%9C%86%E5%9C%88%E4%B8%AD%E6%9C%80%E5%90%8E%E5%89%A9%E4%B8%8B%E7%9A%84%E6%95%B0%E5%AD%97"><span class="nav-number">59.</span> <span class="nav-text">62.圆圈中最后剩下的数字</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#29-%E9%A1%BA%E6%97%B6%E9%92%88%E6%89%93%E5%8D%B0%E7%9F%A9%E9%98%B5"><span class="nav-number">60.</span> <span class="nav-text">29.顺时针打印矩阵</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#31-%E6%A0%88%E7%9A%84%E5%8E%8B%E5%85%A5%E3%80%81%E5%BC%B9%E5%87%BA%E5%BA%8F%E5%88%97"><span class="nav-number">61.</span> <span class="nav-text">31.栈的压入、弹出序列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#20-%E8%A1%A8%E7%A4%BA%E6%95%B0%E5%80%BC%E7%9A%84%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="nav-number">62.</span> <span class="nav-text">20.表示数值的字符串</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#67-%E6%8A%8A%E5%AD%97%E7%AC%A6%E4%B8%B2%E8%BD%AC%E6%8D%A2%E6%88%90%E6%95%B4%E6%95%B0"><span class="nav-number">63.</span> <span class="nav-text">67.把字符串转换成整数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#59-1-%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-number">64.</span> <span class="nav-text">59_1.滑动窗口的最大值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#59-2-%E9%98%9F%E5%88%97%E7%9A%84%E6%9C%80%E5%A4%A7%E5%80%BC"><span class="nav-number">65.</span> <span class="nav-text">59_2.队列的最大值</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#37-%E5%BA%8F%E5%88%97%E5%8C%96%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="nav-number">66.</span> <span class="nav-text">37.序列化二叉树</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#38-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%8E%92%E5%88%97"><span class="nav-number">67.</span> <span class="nav-text">38.字符串的排列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#19-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%E5%8C%B9%E9%85%8D"><span class="nav-number">68.</span> <span class="nav-text">19.正则表达式匹配</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#49-%E4%B8%91%E6%95%B0"><span class="nav-number">69.</span> <span class="nav-text">49.丑数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#60-n%E4%B8%AA%E9%AA%B0%E5%AD%90%E7%9A%84%E7%82%B9%E6%95%B0"><span class="nav-number">70.</span> <span class="nav-text">60.n个骰子的点数</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#51-%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%80%86%E5%BA%8F%E5%AF%B9"><span class="nav-number">71.</span> <span class="nav-text">51.数组中的逆序对</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#14-2-%E5%89%AA%E7%BB%B3%E5%AD%90"><span class="nav-number">72.</span> <span class="nav-text">14_2.剪绳子</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">zhaoxfan</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
